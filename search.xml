<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统面试题总结</title>
      <link href="/2024/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络面试题总结</title>
      <link href="/2024/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2024/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hello earth！</title>
      <link href="/2024/02/21/hello-earth-md/"/>
      <url>/2024/02/21/hello-earth-md/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法分析与设计</title>
      <link href="/2024/02/21/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-md/"/>
      <url>/2024/02/21/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-md/</url>
      
        <content type="html"><![CDATA[<h1 id="1-分治"><a href="#1-分治" class="headerlink" title="1.分治"></a>1.分治</h1><h3 id="1-1-递归分治"><a href="#1-1-递归分治" class="headerlink" title="1.1 递归分治"></a>1.1 递归分治</h3><h4 id="p6001-归并排序"><a href="#p6001-归并排序" class="headerlink" title="p6001-归并排序"></a>p6001-归并排序</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​给定一个长度为<code>n</code>的数列，包含<code>n</code>个整数。你的任务是编写一个程序，使用归并排序算法将这个数列按照升序排列，并输出排序后的数列。</p><p><strong>Input</strong></p><p>​第一行包含一个整数<code>n</code>，表示数列中的元素个数。</p><p>​第二行包含<code>n</code>个整数，数列中的每个元素，整数之间由空格分隔。</p><p><strong>Output</strong></p><p>​输出一行，包含<code>n</code>个整数，为按照升序排列后的数列，整数之间由空格分隔。在行末输出一个换行符。</p><p><strong>解题思路：</strong></p><p>​掌握归并排序的分治思想，采用递归分解成一个一个小问题，最后小问题汇总成大问题。归并排序算法有两个基本的操作，一个是分，也就是把原数组划分成两个子数组的过程。另一个是治，它将两个有序数组合并成一个更大的有序数组。将待排序的线性表不断地切分成若干个子表，直到每个子表只包含一个元素，这时，可以认为只包含一个元素的子表是有序表。将子表两两合并，每合并一次，就会产生一个新的且更长的有序表，重复这一步骤，直到最后只剩下一个子表，这个子表就是排好序的线性表。</p><p><img src="/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-md.assets/20200209191150963.png" alt="img"></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 由于需要先递归到最深处，且在第三次走到结点位置时才需要进行计算，所以应该是头递归（即递归应该放在正常函数的前面）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    <span class="type">int</span> mid = (r+l)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i = l, j = mid;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt;= nums[j])&#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; mid)&#123;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r)&#123;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i++)&#123;</span><br><span class="line">        nums[i] = temp[i-l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (r+l)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">mergeSort</span>(nums, l, mid);</span><br><span class="line">    <span class="built_in">mergeSort</span>(nums, mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">merge</span>(nums, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mergeSort</span>(nums, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">       cout &lt;&lt;  nums[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p6002-求逆序对的数量"><a href="#p6002-求逆序对的数量" class="headerlink" title="p6002-求逆序对的数量"></a>p6002-求逆序对的数量</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​给定一个长度为<code>n</code>的整数数列，你的目标是计算出数列中逆序对的总数。逆序对定义为数列中一对元素<code>(a[i], a[j])</code>，其中<code>i &lt; j</code>且<code>a[i] &gt; a[j]</code>。</p><p><strong>Input</strong></p><p>​第一行包含一个整数<code>n</code>，表示数列中的元素个数。</p><p>​第二行包含<code>n</code>个整数，表示数列的元素，元素之间由一个空格分隔。</p><p><strong>Output</strong></p><p>​输出一个整数，表示数列中逆序对的总数。</p><p><strong>解题思路：</strong></p><p>​由于在归并排序两个数组merge的过程中，我们需要新开一个temp数组来将两边的数组进行排序，这时一旦左半边的nums[i]大于右半边的nums[j]，那么从第i个开始到左半边的结束全是逆序对。相当于求逆序对的数量，比归并排序就多了一行代码。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; temp;</span><br><span class="line">    <span class="type">int</span> mid = (r+l)/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i = l, j = mid;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt;= nums[j])&#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">            <span class="comment">// 在归并排序的过程中就可以查找，与归并排序唯一不同的地方就是在此处计算了逆序对的数量</span></span><br><span class="line">            <span class="comment">// 如果nums[i] &gt; nums[j]，那么从i到mid全是逆序对。</span></span><br><span class="line">            num += (mid-i);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; mid)&#123;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r)&#123;</span><br><span class="line">        temp.<span class="built_in">push_back</span>(nums[j]);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; i++)&#123;</span><br><span class="line">        nums[i] = temp[i-l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (r+l)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">mergeSort</span>(nums, l, mid);</span><br><span class="line">    <span class="built_in">mergeSort</span>(nums, mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">merge</span>(nums, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mergeSort</span>(nums, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    cout &lt;&lt; num;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p6003-求第k小的数"><a href="#p6003-求第k小的数" class="headerlink" title="p6003-求第k小的数"></a>p6003-求第k小的数</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​给定一个长度为<code>n</code>的整数数列和一个整数<code>k</code>，你需要编写一个程序，使用快速选择算法找出并返回数列中第<code>k</code>小的元素。</p><p><strong>Input</strong></p><p>​第一行包含两个整数<code>n</code>和<code>k</code>。</p><p>​第二行包含<code>n</code>个整数，这些整数构成你需要处理的数列，每两个整数之间用空格分隔。</p><p><strong>Output</strong></p><p>​输出仅包含一个整数，即数列中第<code>k</code>小的元素。</p><p><strong>解题思路：</strong></p><p>​快速排序采用“分治”的思想，对于一组数据，选择一个基准元素（base），通常选择第一个或最后一个元素，通过第一轮扫描，比base小的元素都在base左边，比base大的元素都在base右边，再有同样的方法递归排序这两部分，直到序列中所有数据均有序为止。</p><p>​本题采用在快速排序的过程中找到第k小的数。分治思想。因为快排每一次是找到这一块数的第一个数在整个数组的正确位置，所以我们在每次快排完后确认该数是不是第k个数就可以了，如果不是就根据k的大小遍历左边还是右边。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = l, j = r;</span><br><span class="line">    <span class="type">int</span> x = nums[l];</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] &gt;= x)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">            nums[i++] = nums[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] &lt; x)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">            nums[j--] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[i] = x;</span><br><span class="line">    <span class="keyword">if</span>(k == i+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; i+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSort</span>(nums, i+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSort</span>(nums, l, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">quickSort</span>(nums,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p6004-快速幂"><a href="#p6004-快速幂" class="headerlink" title="p6004-快速幂"></a>p6004-快速幂</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​给定<code>n</code>组整数<code>ai, bi, pi</code>，你需要编写一个程序来计算每组<code>(ai^bi) mod pi</code>的结果。</p><p><strong>Input</strong></p><p>​第一行包含一个整数<code>n</code>，表示数据组数。</p><p>​接下来的<code>n</code>行，每行包含三个整数<code>ai, bi, pi</code>。</p><p><strong>Output</strong></p><p>​对于每组输入数据，输出一个整数，即计算得到的<code>(ai^bi) mod pi</code>的值。每个结果输出在单独的一行。</p><p><strong>解题思路：</strong></p><p>​快速幂（Fast Powering）是一种用于高效计算指数幂的算法。它的基本思想是通过将指数进行二进制拆分，并利用指数的二进制表示来减少乘法运算次数。</p><p>​具体而言，假设我们要计算一个数的n次幂，我们可以将n表示为二进制形式，例如，n的二进制表示为1101，那么我们可以将n的次幂表示为：</p><p>​a^n &#x3D; a^(2^0 * 1) * a^(2^1 * 0) * a^(2^2 * 1) * a^(2^3 * 1)</p><p>​可以观察到，n的二进制表示中的每一位对应着该位置上的幂次项是否需要相乘。如果该位是1，我们就需要将对应的幂次项乘到结果中，如果该位是0，我们则不需要。</p><p>​利用这个观察，我们可以通过迭代的方式计算幂次项的乘积。假设我们已经计算出了a^(2^i)，那么我们可以通过将其平方得到a^(2^(i+1))。这样，我们可以利用迭代来计算出所有的幂次项，从而得到最终的结果。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">quickPow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b, <span class="type">long</span> <span class="type">long</span> p)</span></span>&#123;</span><br><span class="line">    a = a % p;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            result = (result * a) % p;</span><br><span class="line">        &#125;</span><br><span class="line">        a = (a * a) % p;</span><br><span class="line">        b /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> a, b, p;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">quickPow</span>(a, b, p) &lt;&lt; endl;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p6005-最大连续子数组和"><a href="#p6005-最大连续子数组和" class="headerlink" title="p6005-最大连续子数组和"></a>p6005-最大连续子数组和</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​给定一个整数数组<code>nums</code>，找出其中的连续子数组（至少包含一个元素）使得该子数组的和最大，并返回这个最大的和。</p><p><strong>Input</strong></p><p>​第一行一个整数n，代表数组的大小</p><p>​第二行，一个整数数组<code>nums</code>，其中<code>1 &lt;= nums.length &lt;= 1000</code>且<code>-10^4 &lt;= nums[i] &lt;= 10^4</code>。</p><p><strong>Output</strong></p><p>​返回该数组中具有最大和的连续子数组的和。</p><p><strong>解题思路：</strong></p><p>​分治思想，想到上方的经典分治图，先递归到最深处再慢慢合起来，所以此处应该是头递归。合的过程中，我们要找到最大的连续子数组，由于我们已经找到左边的最大和右边的最大，还差的就是包含了中间元素的最大。因为最开始两边是截断的，现在合起来了就必须考虑中间的最大。所以最终有三种情况，比较求其最大值，找max(左边的最大，右边的最大，包含中间元素的最大)。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> lmax = <span class="built_in">maxSum</span>(nums, l, mid);</span><br><span class="line">    <span class="type">int</span> rmax = <span class="built_in">maxSum</span>(nums, mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="type">int</span> midSum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> msum, msum1 = -INT_MAX, msum2 = -INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = mid; i &gt;= l; i--)&#123;</span><br><span class="line">        midSum += nums[i];</span><br><span class="line">        msum1 = <span class="built_in">max</span>(midSum, msum1);</span><br><span class="line">    &#125;</span><br><span class="line">    midSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = mid; i &lt;= r; i++)&#123;</span><br><span class="line">        midSum += nums[i];</span><br><span class="line">        msum2 = <span class="built_in">max</span>(midSum, msum2);</span><br><span class="line">    &#125;</span><br><span class="line">    msum = msum1+msum2-nums[mid];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(msum, <span class="built_in">max</span>(lmax, rmax));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">maxSum</span>(nums, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-二分法"><a href="#1-2-二分法" class="headerlink" title="1.2 二分法"></a>1.2 二分法</h3><p>二分有两种经典的写法：</p><p><strong>第一种写法</strong>：</p><p>​我们定义 target 是在一个在左闭右闭的区间里，<strong>也就是[left, right] （这个很重要非常重要）</strong>。</p><p>​区间的定义这就决定了二分法的代码应该如何写，<strong>因为定义target在[left, right]区间，所以有如下两点：</strong></p><ul><li>while (left &lt;&#x3D; right) 要使用 &lt;&#x3D; ，因为left &#x3D;&#x3D; right是有意义的，所以使用 &lt;&#x3D;</li><li>if (nums[middle] &gt; target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1</li></ul><p></p><p><strong>第二种写法：</strong></p><p>​如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。</p><p>有如下两点：</p><ul><li>while (left &lt; right)，这里使用 &lt; ,因为**left &#x3D;&#x3D; right在区间[left, right)**是没有意义的</li><li>if (nums[middle] &gt; target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li></ul><h4 id="p6011-有序数组中查找数1"><a href="#p6011-有序数组中查找数1" class="headerlink" title="p6011-有序数组中查找数1"></a>p6011-有序数组中查找数1</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​给定一个严格单调递增的序列，这个序列经过一次旋转后，可能在某个枢轴点上发生了旋转，导致原有序列被分为两部分，前面部分的所有元素都大于后面部分的所有元素，如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">原始序列：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7</span><br><span class="line">旋转后的序列：4 -&gt; 5 -&gt; 6 -&gt; 7 -&gt; 1 -&gt; 2 -&gt; 3</span><br></pre></td></tr></table></figure><p>​旋转后的序列依旧保持了分段的单调递增特性。请编写一个算法，找出并返回旋转后序列中的最小元素。</p><p>​假设序列中不存在重复元素。</p><p><strong>Input</strong></p><ul><li>第一行 n, (0 &lt; n &lt; 10000000)</li><li>第二行，n个整数，一个整数数组，代表旋转后的序列。</li></ul><p><strong>Output</strong></p><p>​序列中的最小元素。</p><p><strong>解题思路：</strong></p><p>​使用二分查找。由于给定的序列是严格单调递增的，并且经过一次旋转后可能发生了旋转，我们可以利用这个性质来缩小查找范围。首先初始化左边界l为序列的起始位置，右边界r为序列的结束位置。进行二分查找。在每次迭代中，计算出中点mid，即(l + r) &#x2F; 2。我们可以比较mid位置的元素与左边界l位置的元素以及右边界r位置的元素。</p><ul><li><p>如果mid位置的元素大于等于左边界l位置的元素，说明mid位置在旋转点之前，即左半部分是有序的。此时，我们可以将左边界l更新为mid+1，继续在右半部分进行查找。</p></li><li><p>如果mid位置的元素小于等于右边界r位置的元素，说明mid位置在旋转点之后，即右半部分是有序的。此时，我们可以将右边界r更新为mid-1，继续在左半部分进行查找。</p><p>重复上方，直到找到旋转点。当左边界l和右边界r相遇时，即找到了旋转点。</p></li></ul><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">  <span class="comment">// 关闭输入输出缓存，使效率提升</span></span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 解除cin和cout的默认绑定，来降低IO的负担使效率提升</span></span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">NULL</span>); cout.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>, mid;</span><br><span class="line">  <span class="keyword">if</span>(nums[l] &lt; nums[r])&#123;</span><br><span class="line">  cout &lt;&lt; nums[l];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt;= nums[<span class="number">0</span>])&#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; nums[l];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p6012-有序数列中查找数2"><a href="#p6012-有序数列中查找数2" class="headerlink" title="p6012-有序数列中查找数2"></a>p6012-有序数列中查找数2</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>实现一个算法，在一个升序排列的整数数组中找到一个给定整数<code>k</code>的起始位置和终止位置。如果这个整数在数组中出现多次，起始位置指的是<code>k</code>首次出现的索引(索引从<code>0</code>开始计算)，终止位置是<code>k</code>最后一次出现的索引。如果<code>k</code>在数组中没有出现，则需要返回一对<code>-1</code>。</p><p><strong>Input</strong></p><ul><li>第一行包含两个整数<code>n</code>和<code>q</code>，其中<code>n</code>是数组的长度，<code>q</code>是查询的次数。</li><li>第二行包含<code>n</code>个升序排列的整数，表示数组的内容。</li><li>接下来的<code>q</code>行，每行包含一个整数<code>k</code>，表示需要查询的数字。</li></ul><p><strong>Output</strong></p><ul><li>对于每个查询，输出一行，包含两个整数，即数字<code>k</code>的起始位置和终止位置。</li><li>如果数组中不存在该元素，则输出<code>-1 -1</code>。</li></ul><p><strong>解题思路：</strong></p><p>​利用二分查找，先找左边界，再找右边界。找左边界时将r尽量往左边缩短，等于的时候依然往左。找右边界时将l尽量往右边缩短，等于的时候依然往右。<strong>二分主要就是边界问题，左边界往左压，右边界往右压</strong>。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">leftDivideTwo</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (r-l)/<span class="number">2</span> + l;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt;= k)&#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[l] == k? l: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rightDivideTwo</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (r-l)/<span class="number">2</span> + l;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; k)&#123;</span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[r] == k? r: <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="type">int</span> k;</span><br><span class="line">        cin &gt;&gt; k;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">leftDivideTwo</span>(nums, k) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">rightDivideTwo</span>(nums, k) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p6013-求数的三次方根"><a href="#p6013-求数的三次方根" class="headerlink" title="p6013-求数的三次方根"></a>p6013-求数的三次方根</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>在一片森林里，有 n 棵树，每棵树的高度不相同。伐木工人需要从这些树中砍下 k 段等长的木材。为了使得所砍的木材尽可能地长，需要确定砍树时每段木材的最大可能长度。要求输出的木材长度是整数。</p><p><strong>Input</strong></p><ul><li>第一行输入包含两个整数 n 和 k，其中 n 表示树的总数，k 表示需要砍下的木材段数。</li><li>第二行输入包含 n 个整数，每个整数表示一棵树的高度。</li></ul><p><strong>Output</strong></p><ul><li>输出一个整数，表示伐木工人能砍得的最长木材长度。</li></ul><p><strong>解题思路：</strong></p><p>​在这个算法中，我们首先初始化左边界l为数据的左范围-10000，右边界r为数据的右范围10000。然后，我们不断将区间长度除以2，直到达到指定的精度。</p><p>​在每一次迭代中，我们计算出中点mid，即(l + r) &#x2F; 2，并根据问题的要求进行相应的操作。根据问题的性质，我们可以根据mid的取值调整左边界l或右边界r的值，以逐渐缩小区间。这样，我们可以通过二分查找的方式逼近所求的答案。<strong>注意 r - l的取值与所求答案要求精度, 一般比要求高的 2。</strong></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">double</span> l = <span class="number">-1e4</span>, r = <span class="number">1e4</span>;</span><br><span class="line">    <span class="keyword">while</span>(r-l &gt; <span class="number">1e-8</span>)&#123;</span><br><span class="line">        <span class="type">double</span> mid = (r+l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(mid * mid * mid &lt; n)&#123;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(mid * mid * mid &gt; n)&#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.6f&quot;</span>, mid);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6f&quot;</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p6014-砍树"><a href="#p6014-砍树" class="headerlink" title="p6014-砍树"></a>p6014-砍树</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>在一片森林里，有 n 棵树，每棵树的高度不相同。伐木工人需要从这些树中砍下 k 段等长的木材。为了使得所砍的木材尽可能地长，需要确定砍树时每段木材的最大可能长度。要求输出的木材长度是整数。</p><p><strong>Input</strong></p><ul><li>第一行输入包含两个整数 n 和 k，其中 n 表示树的总数，k 表示需要砍下的木材段数。</li><li>第二行输入包含 n 个整数，每个整数表示一棵树的高度。</li></ul><p><strong>Output</strong></p><ul><li>输出一个整数，表示伐木工人能砍得的最长木材长度。</li></ul><p><strong>解题思路：</strong></p><p>​我们的目标是找到最高的树。我们将使用二分查找的方法来确定每个符合要求的段的长度，并将其赋值给一个变量。这个变量将始终保持递增。</p><p>​首先，我们需要确定二分查找的左边界l和右边界r。左边界l可以设为0，表示树的最低高度，而右边界r可以根据问题的要求来确定，通常是已知的树的最高高度。</p><p>​然后，我们开始进行二分查找。在每次迭代中，我们计算出中点mid，即(l + r) &#x2F; 2，并根据问题的要求来判断mid是否符合要求。如果mid符合要求，我们将其赋值给一个变量，并更新左边界l为mid，以继续向右侧搜索更高的树。如果mid不符合要求，我们更新右边界r为mid，以缩小搜索范围，继续向左侧搜索更低的树。</p><p>​通过这种二分查找的方法，我们可以逐步逼近最高的树的高度，并将符合要求的高度赋值给一个变量。由于我们每次只考虑符合要求的段，因此这个变量只会越来越大。最后，当二分查找结束时，我们就可以得到最高的树的高度。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 关闭输入输出缓存，使效率提升</span></span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 解除cin和cout的默认绑定，来降低IO的负担使效率提升</span></span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">NULL</span>); cout.<span class="built_in">tie</span>(<span class="literal">NULL</span>);    </span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">        m = <span class="built_in">max</span>(m, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> l = <span class="number">0</span>, r = m;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> mid = (l+r+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> x: nums)&#123;</span><br><span class="line">            sum += (x/mid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= k)&#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            l = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; k)&#123;</span><br><span class="line">            r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p6015-数列分段"><a href="#p6015-数列分段" class="headerlink" title="p6015-数列分段"></a>p6015-数列分段</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>对于一个长度为 N 的正整数数列，现要将其分成 M 段（M ≤ N），要求每段连续，并使每段的和的最大值尽可能小。</p><p><strong>Input</strong></p><ul><li>第一行包含两个正整数 N 和 M。</li><li>第二行包含 N 个由空格隔开的非负整数，表示数列中的每个元素。</li></ul><p><strong>Output</strong></p><ul><li>输出一个正整数，表示分段后每段和的最大值的最小可能值。</li></ul><p><strong>解题思路：</strong></p><p>​我们的目标是找到一种分割方式，使得分割后的每段和的最大值尽可能小。首先，我们需要找到分成一段的情况下的最大和，即将所有数相加得到的总和r。这个最大和r可以作为二分查找的右边界。</p><p>​然后，我们从0到r开始进行二分查找。在每次迭代中，我们计算出中点mid，即(l + r) &#x2F; 2，并遍历整个数组，检查是否存在一种分割方式，使得每段的和不超过mid。</p><p>​如果存在这样的分割方式，我们将更新右边界r为mid-1，以继续向左侧搜索更小的和。这是因为我们希望找到最小的满足条件的和。</p><p>​如果不存在这样的分割方式，我们将更新左边界l为mid+1，以继续向右侧搜索更大的和。</p><p>​通过不断地二分查找，我们最终将找到满足条件的最小和。这个和即为每段和的最大值。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// cnt计算段数，当最后算出来的段数小于等于要求的段数的时候，才能符合要求</span></span><br><span class="line"><span class="comment">// 例子：假设我和小于等于10，分了6段，但是我只需要5段，这个时候10变小，就只能分出和更大的段，不符合要求，所以要返回cnt&lt;=k。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums,  <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> k, <span class="type">int</span> mid)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum + nums[i] &lt;= mid)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            sum = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt &lt;= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">        h += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = h;</span><br><span class="line">    <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(nums, l, r, k, mid))&#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, mid);</span><br><span class="line">            r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-贪心"><a href="#2-贪心" class="headerlink" title="2.贪心"></a>2.贪心</h1><h3 id="2-1-简单贪心"><a href="#2-1-简单贪心" class="headerlink" title="2.1 简单贪心"></a>2.1 简单贪心</h3><h4 id="p7001-采购礼物"><a href="#p7001-采购礼物" class="headerlink" title="p7001-采购礼物"></a>p7001-采购礼物</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​小明的生日即将到来，他的朋友小红决定为他挑选一些礼物。在礼物商店中，有n种不同的礼物，每种礼物都有一个确定的价格。但小红只带了m单位的钱，她想知道，最多可以为小明买到多少件礼物？</p><p>​请你设计一个算法，帮助小红计算出她最多可以为小明买到多少件礼物。每种物品只买一件。</p><p><strong>Input</strong></p><p>​第一行包含两个整数n和m，分别表示礼物的种类数量和小红携带的钱数。（1 &lt;&#x3D; n &lt;&#x3D; 10^5, 1 &lt;&#x3D; m &lt;&#x3D; 10^9）</p><p>​第二行包含n个整数，表示每种礼物的价格。每件礼物的价格为正整数并且不超过10^4。</p><p><strong>Output</strong></p><p>​输出一个整数，表示小红最多可以为小明买到的礼物数量。</p><p><strong>解题思路：</strong></p><p>​每次优先选价格小的礼物就可以买到更多的礼物。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, money;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; money;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">price</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; price[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(price.<span class="built_in">begin</span>(), price.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        money -= price[i];</span><br><span class="line">        <span class="keyword">if</span>(money &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            num += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; num;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p7002-硬币找零"><a href="#p7002-硬币找零" class="headerlink" title="p7002-硬币找零"></a>p7002-硬币找零</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​Alice在学校的小店里工作，她的任务是售卖各种小零食和饮料。每当有顾客购买商品并付款后，她需要给顾客找零。在小店中，找零硬币的面值有1、5、10、20和50。Alice想要通过使用最少的硬币数量来找零，这样既可以减少小店的零钱消耗，又可以方便顾客。</p><p>​现在，假设一个顾客购买的商品总价是(100 - n)元，顾客递给Alice一张100元的纸币。请设计一个算法，计算Alice最少需要使用多少张硬币来找给顾客(100 - n)元的零钱。</p><p><strong>Input</strong></p><p>​输入一整数n (1 &lt;&#x3D; n &lt;&#x3D; 99)，表示顾客购买商品的总价。</p><p><strong>Output</strong></p><p>​输出一个整数，表示最少需要使用的硬币数量。</p><p><strong>解题思路：</strong></p><p>​每次都尽量找面值大的钱，就可以找最少使用的钱。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> change = <span class="number">100</span> - n;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(change != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(change &gt;= <span class="number">50</span>)&#123;</span><br><span class="line">            num += <span class="number">1</span>;</span><br><span class="line">            change -= <span class="number">50</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(change &gt;= <span class="number">20</span> &amp;&amp; change &lt; <span class="number">50</span>)&#123;</span><br><span class="line">            num += <span class="number">1</span>;</span><br><span class="line">            change -= <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(change &gt;= <span class="number">10</span> &amp;&amp; change &lt; <span class="number">20</span>)&#123;</span><br><span class="line">            num += <span class="number">1</span>;</span><br><span class="line">            change -= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(change &gt;= <span class="number">5</span> &amp;&amp; change &lt; <span class="number">10</span>)&#123;</span><br><span class="line">            num += <span class="number">1</span>;</span><br><span class="line">            change -= <span class="number">5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(change &gt;= <span class="number">1</span> &amp;&amp; change &lt; <span class="number">5</span>)&#123;</span><br><span class="line">            num += <span class="number">1</span>;</span><br><span class="line">            change -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; num;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p7003-部分背包问题"><a href="#p7003-部分背包问题" class="headerlink" title="p7003-部分背包问题"></a>p7003-部分背包问题</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​在一个古老的金矿中，矿工们找到了n（0 &lt; n &lt;&#x3D; 100）堆不同重量和价值的金币。由于他们只有一个小袋子，所以不能把所有的金币都搬走。小袋子最多能装T（0 &lt; T &lt;&#x3D; 1000）单位的重量。每堆金币有一个总重量m和总价值v，且 1 &lt;&#x3D; m, v &lt;&#x3D; 100。</p><p>​矿工们想知道，他们应该如何选择和分割金币堆，以便他们可以携带走最大价值的金币。</p><p>​请你设计一个算法，计算矿工们可以携带走的金币的最大价值。</p><p><strong>Input</strong></p><p>​第一行包含两个整数n和T，分别表示金币堆的数量和小袋子的最大承重。</p><p>​接下来的n行，每行包含两个浮点数，分别是第i堆金币总重量m和总价值v。</p><p><strong>Output</strong></p><p>​输出一个小数，表示矿工们可以携带走的金币的最大价值，结果保留两位小数。</p><p><strong>解题思路：</strong></p><p>这个问题与背包问题不同的地方在于我们可以逐个选择金币而不是必须一次性取走所有金币。因此，我们可以通过一种贪心的策略来解决这个问题。</p><p>具体步骤如下：</p><ol><li>首先，我们计算每堆金币的平均价值。将每堆金币的总价值除以堆中金币的数量，得到平均价值。</li><li>接下来，我们按照平均价值的降序对所有金币堆进行排序。这样，我们就可以先选择平均价值最大的金币堆进行拿取。</li><li>依次遍历排序后的金币堆列表，按照降序选择金币堆并逐个拿取。我们先选择平均价值最大的金币堆，然后选择平均价值次大的金币堆，以此类推。</li></ol><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">double</span>&gt; &amp;a, <span class="type">const</span> vector&lt;<span class="type">double</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">2</span>] &gt; b[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; t;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">double</span>&gt;&gt; <span class="built_in">nums</span>(n, <span class="built_in">vector</span>&lt;<span class="type">double</span>&gt;(<span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i][<span class="number">0</span>] &gt;&gt; nums[i][<span class="number">1</span>];</span><br><span class="line">        nums[i][<span class="number">2</span>] = nums[i][<span class="number">1</span>]/nums[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), compare);</span><br><span class="line">    <span class="comment">// 这里的sum处理的比较巧妙。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t &gt;= nums[i][<span class="number">0</span>])&#123;</span><br><span class="line">            sum += nums[i][<span class="number">1</span>];</span><br><span class="line">            t -= nums[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sum += nums[i][<span class="number">2</span>] * t;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-区间贪心"><a href="#2-2-区间贪心" class="headerlink" title="2.2 区间贪心"></a>2.2 区间贪心</h3><h4 id="p7004-区间选点"><a href="#p7004-区间选点" class="headerlink" title="p7004-区间选点"></a>p7004-区间选点</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​给定 ( N ) 个闭区间 ([a_i, b_i])，需要在数轴上选择尽可能少的点，以确保每个区间内至少包含一个选出的点。位于区间端点上的点也算作区间内。</p><p><strong>Input</strong></p><ul><li>第一行包含整数 ( N )，表示区间数量。</li><li>接下来的 ( N ) 行，每行包含两个整数 ( a_i, b_i )，表示一个区间的两个端点。</li></ul><p>数据范围</p><ul><li>( 1 &lt;&#x3D; N &lt;&#x3D; 10^5 )</li><li>( -10^9 &lt;&#x3D; a_i &lt;&#x3D; b_i &lt;&#x3D; 10^9 )</li></ul><p><strong>Output</strong></p><ul><li>输出一个整数，表示所需选择的点的最小数量。</li></ul><p><strong>解题思路：</strong></p><p>​当面临一个区间贪心问题时，一种常见的思路是对区间按照左边界或者右边界进行排序。如果我们按照右边界进行排序，那么我们可以从最左边的区间开始遍历；如果按照左边界进行排序，我们则可以从最右边的区间开始遍历。</p><p>​这种排序的思路可以帮助我们更好地处理区间之间的关系。通过排序，我们可以确保在遍历过程中，当前区间的右边界（或左边界）是已经遍历的区间中最小（或最大）的。这样做的好处是，在选择下一个区间时，我们可以根据当前区间的右边界（或左边界）来判断是否与下一个区间有重叠或符合某些特定的条件。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> node &amp;a, <span class="type">const</span> node &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;node&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i].l &gt;&gt; nums[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), compare);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; )&#123;</span><br><span class="line">        <span class="type">int</span> x = nums[i].r;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; x &gt;= nums[i].l)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == n)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p7005-最优活动安排"><a href="#p7005-最优活动安排" class="headerlink" title="p7005-最优活动安排"></a>p7005-最优活动安排</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​假设你是一个活动策划者，你有n个活动需要在同一天举办。每个活动有一个开始时间和结束时间，我们可以假设它们都是整数，并且在同一时间内只能进行一个活动。你的任务是安排这些活动，以便可以举办尽可能多的活动。</p><p><strong>Input</strong></p><p>​输入的第一行包含一个整数n（1 &lt;&#x3D; n &lt;&#x3D; 10^6），表示活动的数量。</p><p>​接下来的n行，每行包含两个整数s和f（0 &lt;&#x3D; s &lt; f &lt;&#x3D; 10^9），表示活动的开始时间和结束时间。</p><p><strong>Output</strong></p><p>​返回可以举办的最大活动数量。</p><p><strong>解题思路：</strong></p><p>​当我们面临需要安排更多活动的问题时，可以采用按照活动的结束时间进行排序的策略，并从最左边的活动开始遍历。这种排序方式的目的是为了优先选择那些结束时间较早的活动，以便为后续活动留下更多的时间。</p><p>​通过按照结束时间排序，我们可以保证在遍历过程中，当前活动的结束时间是已经遍历的活动中最早的。这样，在选择下一个活动时，我们可以根据当前活动的结束时间来判断是否与下一个活动有重叠或满足其他特定的条件。</p><p>​该题与p7004思想基本相同。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> node &amp;a, <span class="type">const</span> node &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;node&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i].l &gt;&gt; nums[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), compare);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; )&#123;</span><br><span class="line">        <span class="type">int</span> x = nums[i].r;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; x &gt; nums[i].l)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == n)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p7006-区间覆盖"><a href="#p7006-区间覆盖" class="headerlink" title="p7006-区间覆盖"></a>p7006-区间覆盖</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​给定 N 个闭区间 [a_i, b_i] 以及一个指定的线段区间 [s, t] ，需要选择尽可能少的区间来完全覆盖指定的线段区间。</p><p><strong>Input</strong></p><ul><li>第一行包含两个整数 ( s ) 和 ( t )，表示给定线段区间的两个端点。</li><li>第二行包含整数 ( N )，表示给定的区间数量。</li><li>接下来的 ( N ) 行，每行包含两个整数 ( a_i, b_i )，表示一个区间的两个端点。</li></ul><p>数据范围：</p><ul><li>( 1 &lt;&#x3D; N &lt;&#x3D; 10^5 )</li><li>( -10^9 &lt;&#x3D; a_i &lt;&#x3D; b_i &lt;&#x3D; 10^9 )</li><li>( -10^9 &lt;&#x3D; s &lt;&#x3D; t &lt;&#x3D; 10^9 )</li></ul><p><strong>Output</strong></p><ul><li>输出一个整数，表示所需的最少区间数。</li><li>如果无法完全覆盖给定的线段区间，则输出 (-1)。</li></ul><p><strong>解题思路：</strong></p><p>​我们首先按照区间的左边界从小到大进行排序。这样，我们可以确保在遍历过程中，当前考虑的区间的左边界是已经遍历的区间中最小的。</p><p>​接下来，我们使用一个循环来遍历排序后的区间。在每次循环中，我们会尝试找到一个覆盖尽可能少的区间。具体而言，我们在目标左边界的范围内查找数组区间中最大的右边界。</p><p>​我们可以使用一个计数器来记录已选择的区间数量。开始时，计数器为0。然后，我们使用一个for循环来遍历排序后的区间。在每次循环中，我们检查当前区间的左边界是否在目标左边界的范围内。如果是，我们更新目标左边界为当前区间的右边界，并将计数器加一，表示我们已经选择了这个区间。</p><p>​接下来，我们继续循环，寻找下一个覆盖尽可能少的区间。我们重复这个过程，直到遍历完所有的区间。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> node &amp;a, <span class="type">const</span> node &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.l &lt; b.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> s, t;</span><br><span class="line">    cin &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;node&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i].l &gt;&gt; nums[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), compare);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, j, rmax;</span><br><span class="line">    <span class="type">bool</span> is_success;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        j = i, rmax=-INT_MAX;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; nums[j].l &lt;= s)&#123;</span><br><span class="line">            rmax = <span class="built_in">max</span>(rmax, nums[j].r);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(rmax &lt; s)&#123;</span><br><span class="line">            is_success = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            s = rmax;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span>(s &gt;= t)&#123;</span><br><span class="line">                is_success = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (is_success == <span class="literal">false</span>) cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p7007-数列分段"><a href="#p7007-数列分段" class="headerlink" title="p7007-数列分段"></a>p7007-数列分段</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​给定一个长度为 ( N ) 的正整数数列 ( A_i )，需要将其分割成若干连续的子段，使得每个子段的元素和不超过 ( M )（可以等于 ( M )）。目标是找出最少能将数列分成多少段，以满足上述条件。</p><p><strong>Input</strong></p><ul><li>第一行包含两个正整数 ( N, M )，分别表示数列 ( A_i ) 的长度和每段的最大和。</li><li>第二行包含 ( N ) 个由空格隔开的非负整数 ( A_i )。</li></ul><p>数据范围：</p><ul><li>( 1 &lt;&#x3D; N &lt;&#x3D; 10^5 )</li><li>( 1 &lt;&#x3D; M &lt;&#x3D; 10^9 )</li><li>( 1 &lt;&#x3D; A_i &lt;&#x3D; M )</li></ul><p><strong>Output</strong></p><ul><li>输出一个正整数，表示最少划分的段数。</li></ul><p><strong>解题思路：</strong></p><p>​按for循环顺序依次更新每段长度使得每段长度最逼近m即可，计数器加一，然后重新开始记录每段长度。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum + nums[i] &lt;= m)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            sum = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-实际场景贪心"><a href="#2-3-实际场景贪心" class="headerlink" title="2.3 实际场景贪心"></a>2.3 实际场景贪心</h3><h4 id="p7011-股票交易"><a href="#p7011-股票交易" class="headerlink" title="p7011-股票交易"></a>p7011-股票交易</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​你是一位股票交易员，你现在有一支股票的价格列表，其中第<code>i</code>天的股票价格是<code>prices[i]</code>。设计一个算法来找到获取最大利润的交易策略。交易规则如下：</p><ul><li><p>你可以进行多次交易，但是必须在再次购买前卖出股票。</p><p>请返回你能获得的最大利润。</p></li></ul><p><strong>Input</strong></p><ul><li>第一行一个整数<code>n</code></li><li>n个正整数（小于1000），代表一个数组<code>prices</code>，其中<code>prices[i]</code>代表股票在第<code>i</code>天的价格。</li></ul><p><strong>Output</strong></p><p>​返回你能获取的最大利润。</p><p><strong>解题思路：</strong></p><p>​只要后项大于前项，则累加到结果中。想象连续两次涨，就累加了两次的差值，其实就等于 第三次卖 - 第一次买的差值。所以把所有的差值加起来就是最大的利润。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">            sum += (nums[i+<span class="number">1</span>]-nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p7012-排队接水"><a href="#p7012-排队接水" class="headerlink" title="p7012-排队接水"></a>p7012-排队接水</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​有<code>n</code>个人需要排队到一个水龙头处打水。每个人打水所需的时间不同。第<code>i</code>个人打水需要<code>t_i</code>时间单位。我们的目标是安排一个打水的顺序，使得所有人的总等待时间最小。</p><p>​这里的“等待时间”指的是一个人在排队等待打水时所花费的时间。例如，如果一个人排在第一个，那么他的等待时间是 0，因为他不需要等待其他人。但是，排在他后面的人需要等待他打完水。</p><p><strong>Input</strong></p><ul><li>第一行是一个整数<code>n</code>(<code>a &lt;= n &lt;= 1e5</code>) ，表示排队的人数。</li><li>第二行包含<code>n</code>个整数，每个整数<code>t_i</code>(<code>1 &lt;= t_i &lt;= 1e4</code>) 表示第<code>i</code>个人打水所需的时间。</li></ul><p><strong>Output</strong></p><ul><li>输出一个整数，这个整数是所有人等待时间的总和的最小值。</li></ul><p><strong>解题思路：</strong></p><p>​由于每个人都要打水，肯定是时间花费越少的人在前面打，这样后面人的总等待时间就会越少，所以按从小到大排序，再计算时间即可。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        sum += (n<span class="number">-1</span>-i) * nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p7013-仓库选址"><a href="#p7013-仓库选址" class="headerlink" title="p7013-仓库选址"></a>p7013-仓库选址</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​在一条数轴上有<code>N</code>家商店，每家商店都有一个确定的坐标，这些坐标分别为<code>A_1, A_2, ..., A_N</code>。你的任务是在这条数轴上选择一个点建立一个货仓。</p><p>​每天早晨，需要从货仓运送货物到每家商店。为了提高运输效率，你需要选择一个货仓的位置，使得货仓到所有商店的总距离最小。</p><p><strong>Input</strong></p><ul><li>第一行是一个整数<code>N</code>(<code>1 &lt; N &lt; 1e5</code>) ，表示商店的数量。</li><li>第二行是<code>N</code>个整数，<code>A_1, A_2, ..., A_N</code>(<code>0 &lt; A_i &lt; 1e4</code>) ，表示每家商店在数轴上的坐标。</li></ul><p><strong>Output</strong></p><ul><li>输出一个整数，表示货仓到所有商店的总距离的最小可能值。</li></ul><p><strong>解题思路：</strong></p><p>​总距离最小就必须得建到中间，先把数组从小到大排序，很容易理解将仓库建到所有数据的正中间距离是最小的，因为无论是建到两个数据的左边或者右边，他到两个数据的距离都会比建到两个数据的中间长。而建到中间的话距离就等于两个数据的差值，直接计算差值即可。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        sum += (nums[r]-nums[l]);</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p7014-均分图书"><a href="#p7014-均分图书" class="headerlink" title="p7014-均分图书"></a>p7014-均分图书</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​在学校图书馆，管理员小明正在整理一些图书。这些图书被分成了<code>n</code>堆，编号分别为<code>1, 2, ..., n</code>。每堆上有若干本书，但图书的总数必为<code>n</code>的倍数。小明可以在任一堆上取若干本图书，然后移动它们。</p><p>​移动图书的规则为：</p><ul><li><p>在编号为<code>1</code>的堆上取的图书，只能移到编号为<code>2</code>的堆上；</p></li><li><p>在编号为<code>n</code>的堆上取的图书，只能移到编号为<code>n-1</code>的堆上；</p></li><li><p>在其他编号的堆上取的图书，可以移到相邻左边或右边的堆上。</p><p>​现在要求你帮助小明找出一种移动方法，用最少的移动次数使每堆上图书的数量都一样多。</p></li></ul><p><strong>Input</strong></p><ul><li>第一行输入一个整数<code>n</code>(<code>1 &lt;= n &lt;= 100</code>)，表示图书堆的数量。</li><li>第二行输入<code>n</code>个整数<code>a_1, a_2, ... , a_n</code>(<code>1 &lt;= a_i &lt;= 1e5</code>)，用空格隔开，表示每堆图书初始时的数量。保证图书总数是<code>n</code>的倍数。</li></ul><p><strong>Output</strong></p><ul><li>输出一个整数，表示使所有堆均达到相等时的最少移动次数。</li></ul><p><strong>解题思路：</strong></p><p>​因为不等于均值的图书的数据，最少都需要移动一次，所以我遍历整个数组，每个元素我都将他变成均值，要不就是多了给右边，要不就是少于均值从右边拿（那可能会右边不够你拿怎么办？其实没有影响，因为你这一次虽然是拿右边是不够的，但是其实顺序无所谓，本质上你可能是右边的右边先给了右边，然后你再从右边拿的，这个顺序是不影响最后拿的次数的。），等于均值了就不管，然后使用一个计数器计数就可以解决问题。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> average = sum / n;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; average)&#123;</span><br><span class="line">            nums[i+<span class="number">1</span>] += (nums[i]-average);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt; average)&#123;</span><br><span class="line">            nums[i+<span class="number">1</span>] -= (average-nums[i]);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p7015-合并果子"><a href="#p7015-合并果子" class="headerlink" title="p7015-合并果子"></a>p7015-合并果子</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><ol><li>有 n 种果子，每种果子的数量分别为 a1, a2, …, an。</li><li>你可以合并任意两堆果子，每次合并的体力消耗是这两堆果子的总数。</li><li>需要通过 n-1 次合并，使得最终合并的总体力消耗最小。</li></ol><p>计算出达达合并所有果子所需的最小体力消耗值。</p><p><strong>Input</strong></p><ul><li>输入包括两行，第一行是一个整数 n ( 1 &lt;&#x3D; n &lt;&#x3D; 1e4)，表示果子的种类数。</li><li>第二行包含 n 个整数，分别是每种果子的数量。( 1 &lt;&#x3D; a_i &lt;&#x3D; 1e4)</li></ul><p><strong>Output</strong></p><ul><li>输出是一个整数，表示最小的体力消耗值。</li></ul><p><strong>解题思路：</strong></p><p>​要想体力消耗小，那么数量小的肯定要先合并。首先数组从小到大排，将最小的2个合并成一个a。因为合并之后这个a不一定是最小的了，所以a和后面的元素要重新排序，再找出最小的两个再合并，直到最后合并成一堆。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>()+i, nums.<span class="built_in">end</span>());</span><br><span class="line">        cost += (nums[i]+nums[i+<span class="number">1</span>]);</span><br><span class="line">        nums[i+<span class="number">1</span>] += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cost;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3.动态规划"></a>3.动态规划</h1><p><strong>一些小tips：</strong></p><p>​解这种dp问题时他的题目问求什么什么的最大或者最长，一般dp[i]就是求前i个或者以第i个为结尾的最大或最长的。</p><h3 id="3-1-线性DP"><a href="#3-1-线性DP" class="headerlink" title="3.1 线性DP"></a>3.1 线性DP</h3><h4 id="p5002-爬楼梯"><a href="#p5002-爬楼梯" class="headerlink" title="p5002-爬楼梯"></a>p5002-爬楼梯</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​假设你正在爬楼梯，楼梯共有<code>n</code>个阶梯。每次你可以爬<code>1</code>或<code>2</code>个阶梯。计算有多少种不同的方法可以爬到楼梯的顶部。</p><p><strong>Input</strong></p><ul><li>一个正整数<code>n``（ 1 &lt;= n &lt;= 50 ）</code>，表示楼梯的阶梯数。</li></ul><p><strong>Output</strong></p><ul><li>输出一个整数，表示总的方法数。</li></ul><p><strong>解题思路：</strong></p><p>​到达第n阶楼梯有两种方式，从第n-2阶上2步，从第n-1阶上一步，所以得到的状态转移方程为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// 0级楼梯，只有1种方式（不走）</span></span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;  <span class="comment">// 1级楼梯，只有1种方式</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p5003-连续子数组最大和"><a href="#p5003-连续子数组最大和" class="headerlink" title="p5003-连续子数组最大和"></a>p5003-连续子数组最大和</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​给定一个整数数组<code>nums</code>，找出其中的连续子数组（至少包含一个元素）使得该子数组的和最大，并返回这个最大的和。</p><p><strong>Input</strong></p><ul><li>第一行一个整数n，代表数组的大小</li><li>第二行，一个整数数组<code>nums</code>，其中<code>1 &lt;= nums.length &lt;= 10^4</code>且<code>-10^4 &lt;= nums[i] &lt;= 10^4</code>。</li></ul><p><strong>Output</strong></p><ul><li>返回该数组中具有最大和的连续子数组的和。</li></ul><p><strong>解题思路：</strong></p><p>​dp[i]是以第i个元素为结尾的最大连续子数组和，而这个和有两种情况，一种是，要么就是以i-1为结束的和加上第i个数，要么就是只有第i个数，所以得到的状态转移方程为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">      <span class="comment">// 递推公式：dp[i]要么就是上一个加上这个元素，要么就是本身这个元素。</span></span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>]+res[i], res[i]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大连续子数组和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; res[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">      <span class="comment">// 递推公式：dp[i]要么就是上一个加上这个元素，要么就是本身这个元素。</span></span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>]+res[i], res[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p5004-最长上升子序列"><a href="#p5004-最长上升子序列" class="headerlink" title="p5004-最长上升子序列"></a>p5004-最长上升子序列</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​给定一个长度为<code>n``(1 &lt;= n &lt;= 5000) )</code>的正整数序列，其中每个整数不超过<code>10^6</code>，确定<strong>最长严格递增子序列</strong>的长度。</p><p>​递增子序列是原序列的一个子集，其中选取的整数是<strong>按原顺序</strong>并且<strong>严格递增</strong>的。</p><p><strong>Input</strong></p><ul><li>第一行包含一个单独的整数<code>n</code>，表示序列的长度。</li><li>第二行由<code>n</code>个由空格分隔的整数组成，代表该序列。</li></ul><p><strong>Output</strong></p><p>​输出一个单独的整数，代表最长递增子序列的长度。</p><p><strong>解题思路：</strong></p><p>​dp[i]表示i之前包括i的以nums[i]结尾的最长递增子序列的长度。dp[i]只有两种情况，要么就是上一步的最大，要么就是新遍历的这个dp最大。该题会将i之前的元素都遍历一遍，找到最大的递增子序列。状态转移方程为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">// 将i之前的元素都遍历一遍，找到最大的递增子序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res[i] &gt; res[j])&#123;</span><br><span class="line">                <span class="comment">// 递推公式，要么就是之前的最大，要么就就是信遍历的这个比较大。</span></span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 最长递增子序列</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; res[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">// 将i之前的元素都遍历一遍，找到最大的递增子序列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res[i] &gt; res[j])&#123;</span><br><span class="line">                <span class="comment">// 递推公式，要么就是之前的最大，要么就就是信遍历的这个比较大。</span></span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p5005-打家劫舍"><a href="#p5005-打家劫舍" class="headerlink" title="p5005-打家劫舍"></a>p5005-打家劫舍</h4><p>力扣上面有相关变形题：</p><p><a href="https://leetcode.cn/problems/house-robber/description/">198. 打家劫舍 - 力扣（LeetCode）</a></p><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​你是一名独行小偷，计划在夜间沿一条街偷取房屋中的财宝。每间房屋内都有一定数量的金币。但有一个问题，这些房屋都装有连通的报警系统。如果你选择偷取两栋相邻的房屋，警报将会响起。</p><p><strong>Input</strong></p><ul><li>第一行输入一个整数<code>n</code>,<code>（1 &lt;= n &lt;= 100）</code>表示房屋的数量。</li><li>第二行输入<code>n</code>个整数，用空格分隔，表示每个房屋中的金币数量<code>（0 &lt;= 金币数量 &lt;= 400</code>）。</li></ul><p><strong>Output</strong></p><p>​输出一个整数，表示你今晚能偷取的最大金额。</p><p><strong>解题思路：</strong></p><p>​dp[i]表示前i个房子能偷的最多钱。而在处理第i个房子的时候，无非两种情况，偷与不偷。如果不偷第i个房子的话，那么前i个房子偷的最多钱肯定和前i-1个房子偷的最多钱是一样的，即dp[i]&#x3D;dp[i-1]。如果偷第i个房子的话，那么第i-1个房子一定不偷，那么这就与前i-2个房子赚的最多钱相关，即dp[i-2]+nums[i]。状态转移方程为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[i]表示前i个房子能偷的最多钱</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>], dp[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// dp[i]表示前i个房子能偷的最多钱</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">        dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>], dp[i<span class="number">-2</span>]+nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-二维DP"><a href="#3-2-二维DP" class="headerlink" title="3.2 二维DP"></a>3.2 二维DP</h3><h4 id="p5001-数字三角形最大路径和"><a href="#p5001-数字三角形最大路径和" class="headerlink" title="p5001-数字三角形最大路径和"></a>p5001-数字三角形最大路径和</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​给定一个数字三角形，你的任务是找到从三角形的顶部到底部的路径，使得路径上经过的数字之和最大。在每一步，你只能移动到下一行中相邻的数字上。</p><p>例如，给定以下数字三角形：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    7</span><br><span class="line">   3 8</span><br><span class="line">  8 1 0</span><br><span class="line"> 2 7 4 4</span><br><span class="line">4 5 2 6 5</span><br></pre></td></tr></table></figure><p>从<code>7 -&gt; 3 -&gt; 8 -&gt; 7 -&gt; 5</code>的路径产生最大的和30。</p><p><strong>Input</strong></p><ul><li>第一行：一个正整数 r （ 1 &lt;&#x3D; r &lt;&#x3D; 1000），表示数字三角形的行数。</li><li>接下来的 r 行：第 i 行包含 i 个整数，表示数字三角形的第 i 行。</li></ul><p>所有输入数字在 [0, 100] 范围内。</p><p><strong>Output</strong></p><ul><li>输出一个整数，表示从三角形顶部到底部的最大路径和。</li></ul><p><strong>解题思路：</strong></p><p>​dp[i][j]代表第i行第j列的最大和，这个和会选取上一行和自己相邻的两个和的最大值，在加上nums[i][j]，状态转移方程为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">               dp[i][j] = dp[i<span class="number">-1</span>][j]+nums[i][j];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(j == i)&#123;</span><br><span class="line">               dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + nums[i][j];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j]) + nums[i][j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">nums</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)&#123;</span><br><span class="line">            cin &gt;&gt; nums[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = nums[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j]+nums[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j == i)&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + nums[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j]) + nums[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; *<span class="built_in">max_element</span>(dp[n<span class="number">-1</span>].<span class="built_in">begin</span>(), dp[n<span class="number">-1</span>].<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p5006-最长公共子序列"><a href="#p5006-最长公共子序列" class="headerlink" title="p5006-最长公共子序列"></a>p5006-最长公共子序列</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​给定两个字符串<code>A</code>和<code>B</code>，你需要找出它们之间的最长公共子序列的长度。</p><p><strong>Input</strong></p><ul><li>第一行：两个整数<code>N</code>和<code>M</code>，分别表示字符串<code>A</code>和<code>B</code>的长度。(1≤N,M≤1000)</li><li>第二行：长度为<code>N</code>的字符串<code>A</code>。</li><li>第三行：长度为<code>M</code>的字符串<code>B</code>。</li></ul><p><strong>Output</strong></p><ul><li>输出一个整数，代表最长公共子序列的长度。</li></ul><p><strong>解题思路：</strong></p><p>​经典的字符串二维dp，dp[i][j]代表s1前i个字符和s2前j个字符的最长公共子序列长度。两个for循环即可解决。当s1[i] &#x3D;&#x3D; s2[j]时，dp直接由i-1和j-1即可得到，如果不相等的话就由dp[i-1][j], dp[i][j-1]两种状态的最大值转移而来，为什么不考虑dp[i-1][j-1]呢，因为这个是一定小于等于上方两个的。状态转移方程为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">           <span class="comment">// 相等的话直接由i-1和j-1即可得到</span></span><br><span class="line">           <span class="keyword">if</span>(s1[i] == s2[j])&#123;</span><br><span class="line">               dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 不相等的话就由以下两种状态转移而来，为什么不考虑dp[i-1][j-1]呢，因为这个是一定小于等于这两个的。</span></span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="comment">// dp[i][j]代表s1的前i个字符和s2的前j个字符的最长公共子序列长度。</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s1.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(s2.<span class="built_in">size</span>()+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="comment">// 相等的话直接由i-1和j-1即可得到</span></span><br><span class="line">            <span class="keyword">if</span>(s1[i] == s2[j])&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不相等的话就由以下两种状态转移而来，为什么不考虑dp[i-1][j-1]呢，因为这个是一定小于等于这两个的。</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p5007-字符串编辑距离"><a href="#p5007-字符串编辑距离" class="headerlink" title="p5007-字符串编辑距离"></a>p5007-字符串编辑距离</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​给定两个字符串 A 和 B，你的任务是计算将 A 转换为 B 所需的最少操作数。你可以进行以下三种操作：</p><ol><li>删除 A 中的一个字符。</li><li>向 A 中插入一个字符。</li><li>替换 A 中的一个字符为另一个字符。</li></ol><p>请你计算将 A 转换为 B 所需的最小操作数。</p><p><strong>Input</strong></p><ul><li>第一行：一个整数 n，表示字符串 A 的长度。</li><li>第二行：一个长度为 n 的字符串 A。</li><li>第三行：一个整数 m，表示字符串 B 的长度。</li><li>第四行：一个长度为 m 的字符串 B。</li></ul><p>字符串中仅包含大小写字母。</p><p><strong>Output</strong></p><p>​输出一个整数，表示从A转换到B所需的最小操作数。</p><p><strong>解题思路：</strong></p><p>​这是一道经典的字符串变换二维DP，解题思路与状态转移方程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">           <span class="comment">// 如果最后一个字符相等，就直接等于上一个</span></span><br><span class="line">           <span class="comment">// 这里为什么是i-1和j-1，因为字符串里面0代表是第一个，1代表是第二个，和dp数组里面不一样</span></span><br><span class="line">           <span class="comment">// dp里面前i个就是dp[i]，而s1里面第i个就算s1[i-1]</span></span><br><span class="line">           <span class="keyword">if</span>(s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>])&#123;</span><br><span class="line">               dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 如果最后一个不相等，分三种情况，替换：dp[i-1][j-1]，然后把s1[i]换成s2[j]</span></span><br><span class="line">           <span class="comment">// 删除：dp[i-1][j]，先将s1[i]删了，然后就变成了s1的前i-1个变成s2的前j个的次数。</span></span><br><span class="line">           <span class="comment">// 添加：dp[i][j-1]，先把s1的前i个字符变成s2的前j-1个字符，再在s1后面加一个s2[j]。</span></span><br><span class="line">           <span class="keyword">else</span>&#123;</span><br><span class="line">               dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j])+<span class="number">1</span>;</span><br><span class="line">               dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    string s1, s2;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s1 &gt;&gt; m &gt;&gt; s2;</span><br><span class="line">    <span class="comment">//dp[i][j]代表s1的前i个字符转换成s2的前j个字符需要的最少次数</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="comment">// 如果最后一个字符相等，就直接等于上一个</span></span><br><span class="line">            <span class="comment">// 这里为什么是i-1和j-1，因为字符串里面0代表是第一个，1代表是第二个，和dp数组里面不一样</span></span><br><span class="line">            <span class="comment">// dp里面前i个就是dp[i]，而s1里面第i个就算s1[i-1]</span></span><br><span class="line">            <span class="keyword">if</span>(s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果最后一个不相等，分三种情况，替换：dp[i-1][j-1]，然后把s1[i]换成s2[j]</span></span><br><span class="line">            <span class="comment">// 删除：dp[i-1][j]，先将s1[i]删了，然后就变成了s1的前i-1个变成s2的前j个的次数。</span></span><br><span class="line">            <span class="comment">// 添加：dp[i][j-1]，先把s1的前i个字符变成s2的前j-1个字符，再在s1后面加一个s2[j]。</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j])+<span class="number">1</span>;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][m];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-背包问题"><a href="#3-3-背包问题" class="headerlink" title="3.3 背包问题"></a>3.3 背包问题</h3><h4 id="p5011-0-1背包"><a href="#p5011-0-1背包" class="headerlink" title="p5011-0-1背包"></a>p5011-0-1背包</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​给定 N 件物品和一个容量为 V 的背包。每件物品只能使用一次。</p><p>​第<code>i</code>件物品的体积是<code>vi</code>，价值是<code>wi</code>。</p><p>​你的任务是决定将哪些物品装入背包，以使得这些物品的总体积不超过背包容量，同时总价值最大。请输出最大价值。</p><p><strong>Input</strong></p><ul><li>第一行包含两个整数，分别为<code>N</code>和<code>V</code>，表示物品数量和背包容量。</li><li>接下来的 N 行，每行包含两个整数<code>vi</code>和<code>wi</code>，表示第<code>i</code>件物品的体积和价值。</li></ul><p><strong>Output</strong></p><p>​输出一个整数，表示最大价值。</p><p><strong>解题思路：</strong></p><p>​二维dp，dp[i][j]代表在前i个物品里面任意选，装进容量为j的背包里面获得的最大价值。解题思路和代码转移方程为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= v; j++)&#123;</span><br><span class="line">            <span class="comment">// 两种情况，装weight[i]和不装。</span></span><br><span class="line">            <span class="comment">// 不装的话就和装前i-1个一样。</span></span><br><span class="line">            <span class="comment">// 装的话最大就是前i-1个装入容量为j-weight[i]的背包中的价值再加上weight[i]的价值。</span></span><br><span class="line">            <span class="comment">// 为什么是减weight[i]，如果减的比weight[i]小（假设减了a），你说有可能是j-a个容量没装满，也能装下weight[i]。</span></span><br><span class="line">            <span class="comment">// 但是我们已经知道了j-weight[i]的最大价值，如果要j-a比j-weight[i]价值大，那么必须装j-weight[i]装不下而j-a装得下的，那如果再装，剩下的容量肯定就不够装weight[i]。</span></span><br><span class="line">            <span class="comment">// 所以在要装下weight[i]的前提下，j-a的价值是一定等于j-weight[i]的。</span></span><br><span class="line">            <span class="comment">// 为什么是减weight[i]，如果减的比weight[i]大（假设减了a）。那这肯定是小于等于j-weight[i]的最大价值的。</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt;= weight[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="comment">// 为什么是weight[i-1]和value[i-1]，因为你在weight和value数组中第i个数是weight[i-1]</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weight[i<span class="number">-1</span>]]+value[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 装不下weight[i]</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">weight</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">value</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; weight[i] &gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp[i][j]表示选前i个物品装入容量为j的背包里的最大价值</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= v; j++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= v; j++)&#123;</span><br><span class="line">            <span class="comment">// 两种情况，装weight[i]和不装。</span></span><br><span class="line">            <span class="comment">// 不装的话就和装前i-1个一样。</span></span><br><span class="line">            <span class="comment">// 装的话最大就是前i-1个装入容量为j-weight[i]的背包中的价值再加上weight[i]的价值。</span></span><br><span class="line">            <span class="comment">// 为什么是减weight[i]，如果减的比weight[i]小（假设减了a），你说有可能是j-a个容量没装满，也能装下weight[i]。</span></span><br><span class="line">            <span class="comment">// 但是我们已经知道了j-weight[i]的最大价值，如果要j-a比j-weight[i]价值大，那么必须装j-weight[i]装不下而j-a装得下的，那如果再装，剩下的容量肯定就不够装weight[i]。</span></span><br><span class="line">            <span class="comment">// 所以在要装下weight[i]的前提下，j-a的价值是一定等于j-weight[i]的。</span></span><br><span class="line">            <span class="comment">// 为什么是减weight[i]，如果减的比weight[i]大（假设减了a）。那这肯定是小于等于j-weight[i]的最大价值的。</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt;= weight[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="comment">// 为什么是weight[i-1]和value[i-1]，因为你在weight和value数组中第i个数是weight[i-1]</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weight[i<span class="number">-1</span>]]+value[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 装不下weight[i]</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][v];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p5012-多重背包"><a href="#p5012-多重背包" class="headerlink" title="p5012-多重背包"></a>p5012-多重背包</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​你有一个背包，容量为<code>V</code>，以及<code>N</code>种不同类型的物品。每种物品有限数量供选择。</p><p>对于第<code>i</code>种物品：</p><ul><li>它有<code>s_i</code>件可用。</li><li>每件的体积是<code>v_i</code>。</li><li>每件的价值是<code>w_i</code>。</li></ul><p>​请确定如何选择物品放入背包，以确保所选物品的总体积不超过背包的容量，并使所选物品的总价值最大化。输出能够获得的最大价值。</p><p><strong>Input</strong></p><ul><li>第一行：两个整数，分别代表物品的种数<code>N</code>和背包的容积<code>V</code>。</li><li>接下来的<code>N</code>行：每行包含三个整数，代表一种物品的体积<code>v_i</code>、价值<code>w_i</code>和数量<code>s_i</code>。</li></ul><p><strong>Output</strong></p><ul><li>输出一个整数，表示能够获得的最大价值。</li></ul><p><strong>解题思路：</strong></p><p>​每种物品有限个，把他挨个放入weight和value中就变形为01背包了。或者利用完全背包的思想，三重for循环。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多重背包 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NR = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> v[NR], w[NR], s[NR];</span><br><span class="line"><span class="type">int</span> dp[NR][NR];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;v[i], &amp;w[i], &amp;s[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; v[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i] &amp;&amp; v[i] * k &lt;= j; k++)</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">1</span>][j - v[i] * k] + w[i] * k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="p5013-完全背包"><a href="#p5013-完全背包" class="headerlink" title="p5013-完全背包"></a>p5013-完全背包</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​有一个背包，它的容量为<code>V</code>。还有<code>N</code>种不同类型的物品，每种物品都有无限数量可供选择。</p><p>​每种物品的体积为<code>v_i</code>，价值为<code>w_i</code>。</p><p>​请你确定如何选择物品放入背包，以确保物品的总体积不超过背包的容量，并且物品的总价值达到最大。你需要输出最大的价值。</p><p><strong>Input</strong></p><ul><li>第一行：两个整数，分别代表物品的种数<code>N</code>和背包的容积<code>V</code>。</li><li>接下来的<code>N</code>行：每行包含两个整数，分别代表一种物品的体积<code>v_i</code>和价值<code>w_i</code>。</li></ul><p><strong>Output</strong></p><p>​输出一个整数，表示能够获得的最大价值。</p><p><strong>解题思路：</strong></p><p>与01背包唯一不同的地方就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-weight[i<span class="number">-1</span>]]+value[i<span class="number">-1</span>]);</span><br></pre></td></tr></table></figure><p>改成了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = max(dp[i-1][j], dp[i][j-weight[i-1]]+value[i-1]);</span><br></pre></td></tr></table></figure><p>是因为他的代码思想发生了一些变化，看以下代码就能明白，本来是三重循环：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全背包 朴素 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NR = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> v[NR], w[NR];</span><br><span class="line"><span class="type">int</span> dp[NR][NR];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;v[i], &amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; v[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k * v[i] &lt;= j; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i - <span class="number">1</span>][j - k* v[i]] + k * w[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, dp[n][m]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//k的for循环优化</span></span><br><span class="line"><span class="comment">// dp[i][j] = max(dp[i][j], </span></span><br><span class="line"><span class="comment">//        dp[i-1][j-v] + w,  dp[i-1][j-2v] + 2w, dp[i-1][j-3v] + 3w,..) </span></span><br><span class="line"><span class="comment">// dp[i][j-v] = </span></span><br><span class="line"><span class="comment">//        dp[i-1][j-v],  dp[i-1][j-2v] + w, dp[i-1][j-3v] + 2w,..) </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在进行k的for循环优化之后的代码：</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">weight</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">value</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; weight[i] &gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp[i][j]表示选前i个物品装入容量为j的背包里的最大价值</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= v; j++)&#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= v; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; weight[i<span class="number">-1</span>])&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j-weight[i<span class="number">-1</span>]]+value[i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[n][v];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-区间DP"><a href="#3-4-区间DP" class="headerlink" title="3.4 区间DP"></a>3.4 区间DP</h3><h4 id="p5014-股票交易"><a href="#p5014-股票交易" class="headerlink" title="p5014-股票交易"></a>p5014-股票交易</h4><p>力扣的相关题目：</p><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/">123. 买卖股票的最佳时机 III - 力扣（LeetCode）</a></p><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description/">188. 买卖股票的最佳时机 IV - 力扣（LeetCode）</a></p><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​你是一位股票交易员，你现在有一支股票的价格列表，其中第<code>i</code>天的股票价格是<code>prices[i]</code>。设计一个算法来找到获取最大利润的交易策略。交易规则如下：</p><ul><li><p>你可以进行多次交易，但是必须在再次购买前卖出股票。</p></li><li><p>卖出股票后，你不能在当日立即买入（次日可以买卖），也就是必须等待至少一天（冷冻期为一天）。</p><p>请返回你能获得的最大利润。</p></li></ul><p><strong>Input</strong></p><ul><li>第一行一个整数<code>n</code></li><li>n个正整数（小于1000），代表一个数组<code>prices</code>，其中<code>prices[i]</code>代表股票在第<code>i</code>天的价格。</li></ul><p><strong>Output</strong></p><p>​返回你能获取的最大利润。</p><p><strong>解题思路：</strong></p><p>​关键的dp数组含义：dp[i][j]中，j只有0和1两个取值。dp[i][0]代表第i天不持有股票，dp[i][1]代表第i天持有股票，最后答案求dp[n-1][0]即可（因为dp[i][0]随着i的变大是越来越大的，后面的肯定是最大的。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果第i天不持有股票的话，那么有两种情况：若前一天也不持有股票，那么第i天肯定和前一天相等，因为第i天没有买也没卖。若前一天持有股票，那么第i天肯定卖掉了，要加上今天的价格。</span></span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]+nums[i]);</span><br><span class="line"><span class="comment">// 如果第i天持有股票的话也有两种情况：若前一天也持有股票，那么第i天肯定和前一天相等，因为第i天没有买也没卖。若前一天没持有股票，那么第i天肯定买入了，减去今天买入的价格。</span></span><br><span class="line">dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]-nums[i], dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dp[i][1]代表第i天持有股票的股票的利润</span></span><br><span class="line">    <span class="comment">// dp[i][0]代表第i天不持有股票的股票的利润</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = -nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]+nums[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]-nums[i], dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i = 0; i &lt; n; i++)&#123;</span></span><br><span class="line">    <span class="comment">//     for(int j = 0; j &lt; 2; j++)&#123;</span></span><br><span class="line">    <span class="comment">//         cout &lt;&lt; dp[i][j] &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    cout &lt;&lt; dp[n<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p5015-石子合并"><a href="#p5015-石子合并" class="headerlink" title="p5015-石子合并"></a>p5015-石子合并</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>你有<code>N</code>堆石子排成一行。每堆石子有一定的重量，用整数数组表示。你需要通过一系列操作将所有石子合并成一堆。在每次操作中，你可以选择相邻的两堆石子进行合并。合并的代价为这两堆石子的重量之和，合并后新的一堆石子的重量也为这两堆石子的重量之和。</p><p>由于合并的顺序不同，最终的合并代价也会不同。你的任务是找到一种合并顺序，使得合并所有石子的总代价最小，并输出这个最小的合并代价。</p><p><strong>Input</strong></p><ul><li>第一行包含一个整数<code>N</code>，表示石子的堆数。</li><li>第二行包含<code>N</code>个整数，每个整数表示一堆石子的重量。</li></ul><p><strong>Output</strong></p><ul><li>输出一个整数，表示最小的合并代价。</li></ul><p><strong>解题思路：</strong></p><p>​经典区间dp，dp[i][j]代表合并第i个石子到第j个石子需要的最小代价，二维dp取上三角，从左下往右上循环。eg：初始化的是对角线的四个元素，然后求上面斜着的三个元素，再求上方斜着的两个元素，最后求右上角的元素。</p><p><img src="/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-md.assets/image-20240109110226714.png" alt="image-20240109110226714"></p><p>状态转移方程为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len++)&#123;</span><br><span class="line">        <span class="comment">// 从第一个石子开始遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l + len<span class="number">-1</span> &lt;= n; l++)&#123;</span><br><span class="line">            <span class="type">int</span> r = l+len<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">// 在找最小代价的时候要把范围内的合并方法都遍历一遍找最小值。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = l; k &lt; r; k++)&#123;</span><br><span class="line">                dp[l][r] = <span class="built_in">min</span>(dp[l][r], dp[l][k] + dp[k+<span class="number">1</span>][r] + s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">        s[i] = s[i<span class="number">-1</span>] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dp[i][j]代表合并第i个到第j个石子需要的最小代价</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, INT_MAX));</span><br><span class="line">    <span class="comment">// 这个dp的下三角是不放东西的，而我们要求的是dp[0][n]，在右上角</span></span><br><span class="line">    <span class="comment">// 所以得从下面往上面走dp，很容易想到先初始化对角线为0，</span></span><br><span class="line">    <span class="comment">// 从左下往右上走意味着我们要一步一步把斜着的填满。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        dp[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历合并的石子的数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len++)&#123;</span><br><span class="line">        <span class="comment">// 从第一个石子开始遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l + len<span class="number">-1</span> &lt;= n; l++)&#123;</span><br><span class="line">            <span class="type">int</span> r = l+len<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">// 在找最小代价的时候要把范围内的合并方法都遍历一遍找最小值。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = l; k &lt; r; k++)&#123;</span><br><span class="line">                dp[l][r] = <span class="built_in">min</span>(dp[l][r], dp[l][k] + dp[k+<span class="number">1</span>][r] + s[r]-s[l<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; dp[<span class="number">1</span>][n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-回溯"><a href="#4-回溯" class="headerlink" title="4.回溯"></a>4.回溯</h1><p><strong>回溯算法理论基础：</strong></p><p><a href="https://www.programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">代码随想录 (programmercarl.com)</a></p><p>看到回溯脑子里时刻想着这一个树形模板，帮助理解。</p><p><img src="/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1-md.assets/20210130173631174.png" alt="回溯算法理论基础"></p><p><strong>回溯代码模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">backtracking</span>(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-子集排列问题"><a href="#4-1-子集排列问题" class="headerlink" title="4.1 子集排列问题"></a>4.1 子集排列问题</h3><h4 id="p8001-枚举子集2"><a href="#p8001-枚举子集2" class="headerlink" title="p8001-枚举子集2"></a>p8001-枚举子集2</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​写一个递归函数，枚举<code>n</code>个数<code>&#123;x_1 , ... , x_n&#125;</code>中取若干个数的每种方法（子集枚举）. 对每种方法把取出的数从小到大排序，若两种方法中前<code>k-1</code>个数的选取情况相同，则取了第<code>k</code>个数的在前. 例如对<code>n=4</code>,<code>X=&#123;100,20,3,4&#125;</code>,应该按如下顺序给出结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">100,20,3,4</span><br><span class="line">100,20,3</span><br><span class="line">100,20,4</span><br><span class="line">100,20</span><br><span class="line">100,3,4</span><br><span class="line">100,3</span><br><span class="line">100,4</span><br><span class="line">100</span><br><span class="line">20,3,4</span><br><span class="line">20,3</span><br><span class="line">20,4</span><br><span class="line">20</span><br><span class="line">3,4</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>Input</strong></p><p>​第一行一个正整数<code>n</code>。</p><p>​第二行<code>n</code>个正整数。</p><p><strong>Output</strong></p><p>​输出<code>2^n</code>行，每行一个子集，按题目要求排序。</p><p><strong>解题思路：</strong></p><p>​还是套用经典的回溯模板，首先查看输出顺序，因为要先输出原本的数组，所以应该先递归到最深处，然后再输出，故cout应该在dfs后面，利用一个startindex保证数组每次都是从起始的后面开始遍历的，预防重复情况出现。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> startIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">dfs</span>(nums, i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; res.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            cout &lt;&lt; res[j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        res.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="额外-枚举子集3"><a href="#额外-枚举子集3" class="headerlink" title="额外-枚举子集3"></a>额外-枚举子集3</h4><p><strong>题目：</strong></p><p>​给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>​解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p><p><strong>解题思路：</strong></p><p>​思路与枚举子集2差不多，但是他有重复数字，为了排除重复数字的干扰，需要先对输入数组排序，将重复数字变相邻，方便设置一个used数组，判断是否重复使用该数字。</p><p><a href="https://programmercarl.com/0090.%E5%AD%90%E9%9B%86II.html#%E6%80%9D%E8%B7%AF">代码随想录 (programmercarl.com)</a></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">used</span><span class="params">(<span class="number">100000</span>, <span class="number">0</span>)</span></span>; </span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> startindex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(startindex == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = startindex;i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &amp;&amp; used[i<span class="number">-1</span>] == <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(nums, i+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            cout &lt;&lt; res[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            res.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>();</span><br><span class="line">    <span class="built_in">dfs</span>(nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p8002-全排列"><a href="#p8002-全排列" class="headerlink" title="p8002-全排列"></a>p8002-全排列</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​编写一个程序，用于枚举 n 个数 x1, x2, …, xn 的所有排列方式（即全排列枚举）。如果两种排列方式的前 k-1 个数相同，则将第 k 个数序号更小的排列放在前面。例如，当 n&#x3D;3 且 x&#x3D;{100, 20, 5} 时，应该按以下顺序输出结果：{100, 20, 5}, {100, 5, 20}, {20, 100, 5}, {20, 5, 100}, {5, 100, 20}, {5, 20, 100}。</p><p><strong>Input</strong></p><p>​第一行是一个正整数 n。第二行是 n 个正整数，x1, x2, …, xn。</p><p><strong>Output</strong></p><p>​输出n！行，每行显示一个排列，排列应按题目要求的顺序排列。</p><p><strong>解题思路：</strong></p><p>​套用回溯经典模板，使用一个used数组记录该元素的使用记录，每次从0开始循环，将每次的元素存到res数组中，当res的长度和原数组长度相等时，就输出全排列。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">used</span><span class="params">(<span class="number">10000</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(res.<span class="built_in">size</span>() == k)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++)&#123;</span><br><span class="line">            cout &lt;&lt; res[j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!used[i])&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(nums, k);</span><br><span class="line">            used[i] = <span class="number">0</span>;</span><br><span class="line">            res.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(nums, nums.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="额外-全排列2"><a href="#额外-全排列2" class="headerlink" title="额外-全排列2"></a>额外-全排列2</h4><p><strong>题目：</strong></p><p>​编写一个程序，用于枚举 n 个数 x1, x2, …, xn 的所有排列方式（即全排列枚举）。如果两种排列方式的前 k-1 个数相同，则将第 k 个数序号更小的排列放在前面。例如，当 n&#x3D;3 且 x&#x3D;{100, 20, 5} 时，应该按以下顺序输出结果：{100, 20, 5}, {100, 5, 20}, {20, 100, 5}, {20, 5, 100}, {5, 100, 20}, {5, 20, 100}。<strong>注意：数组中可能有重复数字。</strong></p><p><strong>解题思路：</strong></p><p>​思路与全排列相同，多了一个特判条件，即把整个数组排序，used数记录使用情况，遇到重复数字就跳过。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 特判条件</span></span><br><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &amp;&amp; used[i<span class="number">-1</span>] == <span class="literal">false</span>)&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">used</span><span class="params">(<span class="number">10000</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ress;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(res.<span class="built_in">size</span>() == k)&#123;</span><br><span class="line">        ress.<span class="built_in">push_back</span>(res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &amp;&amp; used[i<span class="number">-1</span>] == <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!used[i])&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(nums, k);</span><br><span class="line">            used[i] = <span class="number">0</span>;</span><br><span class="line">            res.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">dfs</span>(nums, nums.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-其他经典回溯问题"><a href="#4-2-其他经典回溯问题" class="headerlink" title="4.2 其他经典回溯问题"></a>4.2 其他经典回溯问题</h3><h4 id="p8003-n皇后问题"><a href="#p8003-n皇后问题" class="headerlink" title="p8003-n皇后问题"></a>p8003-n皇后问题</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​在一个 n×n 的国际象棋棋盘上，需要放置 n 个皇后，使得每一行、每一列以及每条对角线上最多只有一个皇后。这就构成了 n 皇后问题。例如，当 n&#x3D;8 时，八皇后问题就是在 8×8 的棋盘上放置八个皇后，遵循上述规则。</p><p>​你的任务是根据给定的 n，输出 n 皇后问题的前 k 个解。由于每一行必定只有一个皇后，如果两个解的前 k-1 行的皇后位置相同，那么在第 k 行中皇后位置更靠左的解应排在前面（即按字典序排序）。</p><p><strong>Input</strong></p><p>​输入只有一行，包含两个正整数 n 和 k，表示需要求解的是 n 皇后问题的前 k 个解。</p><p><strong>Output</strong></p><p>​输出前 k 个解：每行包含 n 个用空格隔开的正整数，依次表示每组解中第 1, 2, …, n 行的皇后所在的列位置。</p><p><strong>解题思路：</strong></p><p>​套用回溯模板，利用数组下标索引当做行，元素当列，减少数组使用空间。外层循环代表横着的遍历，dfs代表向竖着的向下方遍历，每次都从0开始循环，通过available找到合适的解。每当res数组等于棋盘的长度时，就得到正确答案，输出数组。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">available</span><span class="params">(<span class="type">int</span> column)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> row = res.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(row-i == column-res[i] || row+column == i+res[i] || column == res[i])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(res.<span class="built_in">size</span>() == n)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; res.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            cout &lt;&lt; res[j]+<span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(cnt == k)&#123;</span><br><span class="line">             <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">available</span>(i))&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">dfs</span>(n, k);</span><br><span class="line">            res.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">     <span class="comment">// 关闭输入输出缓存，使效率提升</span></span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 解除cin和cout的默认绑定，来降低IO的负担使效率提升</span></span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">NULL</span>); cout.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">dfs</span>(n, k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p8004-01背包"><a href="#p8004-01背包" class="headerlink" title="p8004-01背包"></a>p8004-01背包</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​给定 N件物品和一个容量为 V 的背包。每件物品只能使用一次。</p><p>​第<code>i</code>件物品的体积是<code>vi</code>，价值是<code>wi</code>。</p><p>​你的任务是决定将哪些物品装入背包，以使得这些物品的总体积不超过背包容量，同时总价值最大。请输出最大价值。</p><p><strong>Input</strong></p><ul><li>第一行包含两个整数，分别为<code>N</code>和<code>V</code>，表示物品数量和背包容量。</li><li>接下来的 N 行，每行包含两个整数<code>vi</code>和<code>wi</code>，表示第<code>i</code>件物品的体积和价值。</li></ul><p><strong>Output</strong></p><p>​输出一个整数，表示最大价值</p><p><strong>解题思路：</strong></p><p>​套用回溯模板，拿一个maxValue记录最大的value，每次加入了weight之后都更新一次maxvalue，直到得到最大的value，其实这个和求子集差不多，只是多了一个把每个子集求和的步骤。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> allVolume = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> allValue = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> n, <span class="type">int</span> startIndex, vector&lt;<span class="type">int</span>&gt; weight, vector&lt;<span class="type">int</span>&gt; value)</span></span>&#123;</span><br><span class="line">    <span class="comment">// if(allVolume &gt; v)&#123;</span></span><br><span class="line">    <span class="comment">//     return;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = startIndex; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(allVolume+weight[i] &lt;= v)&#123;</span><br><span class="line">            allVolume += weight[i];</span><br><span class="line">            allValue += value[i];</span><br><span class="line">            maxValue = <span class="built_in">max</span>(maxValue, allValue);</span><br><span class="line">            <span class="built_in">dfs</span>(v, n, i+<span class="number">1</span>, weight, value);</span><br><span class="line">            allVolume -= weight[i];</span><br><span class="line">            allValue -= value[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, v;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">weight</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">value</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; weight[i] &gt;&gt; value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(v, n, <span class="number">0</span>, weight, value);</span><br><span class="line">    cout &lt;&lt; maxValue;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-分支限界"><a href="#5-分支限界" class="headerlink" title="5.分支限界"></a>5.分支限界</h1><h4 id="p8011-走迷宫"><a href="#p8011-走迷宫" class="headerlink" title="p8011-走迷宫"></a>p8011-走迷宫</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><ul><li><p>一个n×m的二维整数数组表示迷宫。数组中包含的元素只有0</p><p>和1：</p><ul><li><code>0</code>表示这个位置是可以走的路径。</li><li><code>1</code>表示这个位置是不可通过的墙壁。</li></ul></li><li><p>数组的起始位置<code>(1,1)</code>（左上角）和结束位置<code>(n,m)</code>（右下角）的元素保证为<code>0</code>。</p></li><li><p>迷宫至少存在一条从起点到终点的通路。</p></li></ul><p><strong>Input</strong></p><ul><li>第一行两个整数<code>n</code>，<code>m</code>，其中<code>1 ≤ n, m ≤ 100</code></li><li>接下来的<code>n</code>行，每行<code>m</code>个整数,只有<code>0</code>和<code>1</code>，中间用空格隔开</li></ul><p><strong>Output</strong></p><ul><li>输出一个整数，表示从左上角<code>(1,1)</code>到右下角<code>(n,m)</code>的最少移动次数</li></ul><p><strong>解题思路：</strong></p><p>直接用<strong>广度优先搜索</strong>按层扩散就可以。这里可以设计一个visit数组记录已经访问过的结点，避免重复搜索。步骤如下：</p><ol><li>定义迷宫：将迷宫表示为一个二维矩阵，其中墙壁用障碍物表示（通常用1表示），可以通过的路径用通道表示（通常用0表示）。</li><li>定义BFS函数：创建一个BFS函数，用于搜索迷宫路径。该函数应接受起始位置和目标位置作为参数。</li><li>初始化队列和访问状态：创建一个队列，用于存储待访问的位置。同时，创建一个额外的二维矩阵，用于记录每个位置的访问状态。</li><li>将起始位置加入队列，并将其标记为已访问。</li><li>开始BFS：进入一个循环，直到队列为空为止。</li><li>弹出队首位置：从队列中取出一个位置。</li><li>检查是否到达目标位置：检查当前位置是否为目标位置，如果是，则表示找到了迷宫路径，可以结束搜索。</li><li>获取相邻位置：获取当前位置的所有相邻位置（上、下、左、右）。</li><li>检查相邻位置的合法性：对于每个相邻位置，检查其是否越界、是否为障碍物，以及是否已经访问过。如果是非法位置，则跳过。</li><li>标记相邻位置：将合法的相邻位置标记为已访问，并将其加入队列。</li><li>重复步骤 6-10，直到队列为空。</li><li>如果搜索结束时仍未找到目标位置，则表示迷宫中没有可达的路径。</li></ol><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y, step;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> xx, <span class="type">int</span> yy, <span class="type">int</span> stepp)&#123;</span><br><span class="line">        x = xx;</span><br><span class="line">        y = yy;</span><br><span class="line">        step = stepp; <span class="comment">// 记录当前是第几层，即第几步。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; nums, <span class="type">int</span> n, <span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">visit</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    queue&lt;Node&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="built_in">Node</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    visit[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        Node cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 遍历朝四个方向走</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="type">int</span> x = cur.x + d[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> y = cur.y + d[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x == n<span class="number">-1</span> &amp;&amp; y == m<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> cur.step+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; visit[x][y] == <span class="number">0</span> &amp;&amp; nums[x][y] == <span class="number">0</span>)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="built_in">Node</span>(x, y, cur.step+<span class="number">1</span>));</span><br><span class="line">                visit[x][y] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">nums</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">            cin &gt;&gt; nums[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">bfs</span>(nums, n, m);</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="p8012-0-1背包"><a href="#p8012-0-1背包" class="headerlink" title="p8012-0-1背包"></a>p8012-0-1背包</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​给定 N 件物品和一个容量为 V 的背包。每件物品只能使用一次。</p><p>​第<code>i</code>件物品的体积是<code>vi</code>，价值是<code>wi</code>。</p><p>​你的任务是决定将哪些物品装入背包，以使得这些物品的总体积不超过背包容量，同时总价值最大。请输出最大价值。</p><p><strong>Input</strong></p><ul><li>第一行包含两个整数，分别为<code>N</code>和<code>V</code>，表示物品数量和背包容量。</li><li>接下来的 N 行，每行包含两个整数<code>vi</code>和<code>wi</code>，表示第<code>i</code>件物品的体积和价值。</li></ul><p><strong>Output</strong></p><p>​输出一个整数，表示最大价值。</p><p><strong>解题思路：</strong></p><p>​分支限界：利用某种情况能够得到的上限value值进行剪枝。</p><p>​必要框架：<strong>node结构体</strong>（存储该情况下的总价值、总重量，以及bound（分支限界中的关键变量，该变量可以求到该情况下的理论最大价值，将其与之前情况得到的实际value比，如果比他大，就可以继续，如果比他小，那么这一部分bfs就被剪枝掉），一个&lt;重载函数，）、<strong>node类型的优先队列</strong>，利用node里面的&lt;重载函数,使得在计算的时候可以优先计算出实际的最大value，后面的情况就可以直接剪枝、<strong>bfs函数</strong>，首先初始化一个cur，没有实际含义，相当于链表中的头结点，方便之后的循环，根据题意，进行bfs，该题的bfs有两种情况，将该元素放入or不放入背包，两种情况都进行一些判断然后决定是否放入背包，再进行下一层。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, v;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Item</span>&#123;</span><br><span class="line">    <span class="type">double</span> weight;</span><br><span class="line">    <span class="type">double</span> value;</span><br><span class="line">    <span class="comment">// 一个weight有多少value</span></span><br><span class="line">    <span class="type">double</span> density;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> index; <span class="comment">// 索引，记录到第几层了。</span></span><br><span class="line">    <span class="type">int</span> totalweight; <span class="comment">// 现在这种情况的weight和，即背包已经使用了的容量</span></span><br><span class="line">    <span class="type">int</span> totalvalue; <span class="comment">//  现在得到的最大value值</span></span><br><span class="line">    <span class="type">int</span> upperbound; <span class="comment">// 这种情况下最终的理论value最大值。</span></span><br><span class="line">    <span class="comment">// upperbound越大的排在前面</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node&amp; a) <span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> upperbound &lt; a.upperbound;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平均value最大的排前面，因为根据贪心得知，以最小的weight可以得到最大的alue</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> Item&amp; a, <span class="type">const</span> Item&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.density &gt; b.density;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求出该种装背包方法的理论最大value值。</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bound</span><span class="params">(<span class="type">int</span> index, <span class="type">double</span> totalweight, <span class="type">double</span> totalvalue, vector&lt;Item&gt; nums)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = index;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n &amp;&amp; totalweight + nums[i].weight &lt;= v)&#123;</span><br><span class="line">        totalweight += nums[i].weight;</span><br><span class="line">        totalvalue += nums[i].value;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; n)</span><br><span class="line">        totalvalue += (v-totalweight) * (nums[i].density);</span><br><span class="line">    <span class="keyword">return</span> totalvalue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(vector&lt;Item&gt; nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化cur和q</span></span><br><span class="line">    priority_queue&lt;Node&gt; q;</span><br><span class="line">    Node t1, t2, cur;</span><br><span class="line">    <span class="type">int</span> maxvalue = <span class="number">0</span>;</span><br><span class="line">    cur.index = <span class="number">-1</span>;</span><br><span class="line">    cur.totalweight = <span class="number">0</span>;</span><br><span class="line">    cur.totalvalue = <span class="number">0</span>;</span><br><span class="line">    cur.upperbound = <span class="built_in">bound</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, nums);</span><br><span class="line">    q.<span class="built_in">push</span>(cur);</span><br><span class="line">    <span class="comment">// bfs</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        cur = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> index = cur.index+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 情况1：选择放入背包</span></span><br><span class="line">        <span class="keyword">if</span>(cur.totalweight + nums[index].weight &lt;= v)&#123;</span><br><span class="line">            t1.totalweight = cur.totalweight + nums[index].weight;</span><br><span class="line">            t1.totalvalue = cur.totalvalue + nums[index].value;</span><br><span class="line">            t1.index = index;</span><br><span class="line">            t1.upperbound = <span class="built_in">bound</span>(index+<span class="number">1</span>, t1.totalweight, t1.totalvalue, nums);</span><br><span class="line">            maxvalue = <span class="built_in">max</span>(maxvalue, t1.totalvalue);</span><br><span class="line">            <span class="comment">// 因为这一次相比于上一次的情况是多放进了一个物品，</span></span><br><span class="line">            <span class="comment">// 那么他的上界肯定要么会增加， 要么不变，所以不用判断。</span></span><br><span class="line">            q.<span class="built_in">push</span>(t1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 情况2：选择不放入背包。</span></span><br><span class="line">        t2.totalweight = cur.totalweight;</span><br><span class="line">        t2.totalvalue = cur.totalvalue;</span><br><span class="line">        t2.index = index;</span><br><span class="line">        t2.upperbound = <span class="built_in">bound</span>(index, cur.totalweight, cur.totalvalue, nums);</span><br><span class="line">        <span class="comment">// maxvalue = max(maxvalue, t2.totalvalue);</span></span><br><span class="line">        <span class="comment">// 剪枝，如果理论最大值比现在已有的实际value最大值还大，这种情况就可以继续走下去，否则就不走了。</span></span><br><span class="line">        <span class="keyword">if</span>(t2.upperbound &gt; maxvalue)&#123;</span><br><span class="line">            q.<span class="built_in">push</span>(t2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxvalue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; v;</span><br><span class="line">    <span class="function">vector&lt;Item&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i].weight &gt;&gt; nums[i].value;</span><br><span class="line">        nums[i].density = (<span class="type">double</span>)nums[i].value / nums[i].value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>(nums);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p8013-任务分配"><a href="#p8013-任务分配" class="headerlink" title="p8013-任务分配"></a>p8013-任务分配</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​假设有 ( n ) 个任务和 ( n ) 个人。每个人完成每个任务所需的时间都是不同的。你的任务是分配每个人恰好一个任务，以使完成所有任务的总时间最小。</p><p><strong>Input</strong></p><ul><li>第一行包含一个整数<code>n</code>,<code>（1 &lt;= n &lt;= 20）</code>，表示任务和人的数量。</li><li>接下来的<code>n</code>行，每行包含<code>n</code>个整数，表示完成任务的时间矩阵。第<code>i</code>行第<code>j</code>个整数表示第<code>i</code>个人完成第<code>j</code>个任务所需的时间。</li></ul><p><strong>Output</strong></p><ul><li>输出一个整数，表示最小的完成所有任务所需的总时间。</li></ul><p><strong>解题思路：</strong></p><p>​该题思路与p8002差不多，记住三个重要结构：<strong>node</strong>，包含当前最低时间花费、理论最终最小时间花费，任务是否被分配标记数组等。<strong>bound</strong>，求出当前情况下的理论最终最小时间花费，方便剪枝。<strong>bfs</strong>，首先初始化cur，然后for循环一行，即每个人的不同任务，遇到可以的就入队，不可以的就剪枝或跳过。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, ans = INT_MAX;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">nums</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> index; <span class="comment">// 代表已经到第i个人了</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; used; <span class="comment">// 第i个任务是否被分配</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; task; <span class="comment">// 第索引个人分配了第j个任务</span></span><br><span class="line">    <span class="type">int</span> cost; <span class="comment">// 该种情况已经花费的时间</span></span><br><span class="line">    <span class="type">int</span> lowerbound; <span class="comment">// 该种情况理论的最低花费时间</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Node&amp; b) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lowerbound &gt; b.lowerbound; <span class="comment">//越小的越优先出队 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 求该种情况理论的最低花费时间</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bound</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = node.index;</span><br><span class="line">    <span class="type">int</span> mintime = INT_MAX;</span><br><span class="line">    <span class="type">int</span> minsum = node.cost;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = temp+<span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.used[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                mintime = <span class="built_in">min</span>(mintime, nums[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        minsum += mintime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minsum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node cur, t1;</span><br><span class="line">    <span class="comment">// 初始化，相当于头结点，等会方便循环</span></span><br><span class="line">    <span class="comment">// 优先队列将理论花费时间最少的数据放前面先出队计算</span></span><br><span class="line">    priority_queue&lt;Node&gt; q;</span><br><span class="line">    cur.index = <span class="number">-1</span>;</span><br><span class="line">    cur.used.<span class="built_in">resize</span>(n);</span><br><span class="line">    cur.task.<span class="built_in">resize</span>(n);</span><br><span class="line">    cur.cost = <span class="number">0</span>;</span><br><span class="line">    cur.lowerbound = <span class="built_in">bound</span>(cur);</span><br><span class="line">    q.<span class="built_in">push</span>(cur);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        cur = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.used[j] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// t1是cur的下一层</span></span><br><span class="line">                t1.index = cur.index+<span class="number">1</span>;</span><br><span class="line">                t1.used = cur.used;</span><br><span class="line">                <span class="comment">// 将第j个任务标记为用过</span></span><br><span class="line">                t1.used[j] = <span class="number">1</span>;</span><br><span class="line">                t1.task = cur.task;</span><br><span class="line">                <span class="comment">// 标记第t1.index个人分配了第j个任务</span></span><br><span class="line">                t1.task[t1.index] = j;</span><br><span class="line">                <span class="comment">// 更新时间花费</span></span><br><span class="line">                t1.cost = cur.cost + nums[t1.index][j];</span><br><span class="line">                t1.lowerbound = <span class="built_in">bound</span>(t1);</span><br><span class="line">                <span class="comment">// ans记录实际最低花费时间，如果理论最低花费时间都比ans大，那么直接剪枝，反之入队继续计算</span></span><br><span class="line">                <span class="keyword">if</span>(t1.lowerbound &lt; ans)&#123;</span><br><span class="line">                    <span class="comment">// 任务都分配完了，记录实际最低花费时间</span></span><br><span class="line">                    <span class="keyword">if</span>(t1.index == n<span class="number">-1</span>)&#123;</span><br><span class="line">                        ans = <span class="built_in">min</span>(t1.cost, ans);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(t1);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    nums.<span class="built_in">resize</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            cin &gt;&gt; nums[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-递归"><a href="#6-递归" class="headerlink" title="6.递归"></a>6.递归</h1><h4 id="p1002-最大公约数"><a href="#p1002-最大公约数" class="headerlink" title="p1002-最大公约数"></a>p1002-最大公约数</h4><p><strong>题目：</strong></p><p>Description</p><p>给定两个正整数<code>a</code>和<code>b</code>，请写一个函数来计算它们的最大公约数。</p><p>Input</p><p>输入包含两个正整数<code>a</code>和<code>b</code>，分别在一行上，用空格隔开。</p><p>Output</p><p>输出一个正整数，表示<code>a</code>和<code>b</code>的最大公约数</p><p><strong>解题思路：</strong></p><p>​该题的关键就是运用<strong>辗转相除法</strong>，问题解决过程中不用管a和b谁大，对于gcd函数递归中的<strong>参数</strong>，一定记牢！如果要求<strong>最小公倍数</strong>的话，将每个数除以最大公约数再相乘再乘上最大公约数即可。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a%b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p3001-n的阶乘"><a href="#p3001-n的阶乘" class="headerlink" title="p3001-n的阶乘"></a>p3001-n的阶乘</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​给定一个正整数 n，计算其阶乘 n!。n的阶乘定义为从1到 n 的所有正整数的乘积。即： n! &#x3D; 1 * 2 * 3 * … * n</p><p><strong>挑战：</strong><br>不使用任何循环语句（如：for、while）</p><p><strong>Input</strong></p><ul><li>输入仅包含一个正整数 (n)。</li></ul><p><strong>Output</strong></p><ul><li>输出一个正整数，表示 (n!)。</li></ul><p><strong>解题思路：</strong></p><p>​简单递归，注意这里需要用long long，int会越界。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 注意这里需要用long long，int会越界</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">factorial</span>(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p3002-递归剪枝求斐波那契数列"><a href="#p3002-递归剪枝求斐波那契数列" class="headerlink" title="p3002-递归剪枝求斐波那契数列"></a>p3002-递归剪枝求斐波那契数列</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​斐波那契数列是一个非常著名的数列，它的定义如下：</p><ul><li><p>F(0) &#x3D; 0</p></li><li><p>F(1) &#x3D; 1</p></li><li><p>F(n) &#x3D; F(n-1) + F(n-2) ，其中 ( n &gt; 1 )</p><p>给定一个正整数 n ( 1 &lt;&#x3D; n &lt;&#x3D;50 )，请你计算出第 n 个斐波那契数列的值。</p></li></ul><p><strong>Input</strong></p><ul><li>输入仅包含一个正整数 ( n )。</li></ul><p><strong>Output</strong></p><ul><li>输出一个正整数，表示第 ( n ) 个斐波那契数的值。</li></ul><p><strong>解题思路：</strong></p><p>​设置一个a数组，a[i]代表第i个数的值，每次计算都记录一下对应的值，实现剪枝操作。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 拿一个数组</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span> || n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a[n] != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        a[n] = <span class="built_in">Fibonacci</span>(n<span class="number">-1</span>) + <span class="built_in">Fibonacci</span>(n<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">return</span> a[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Fibonacci</span>(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p3006-天平平衡问题"><a href="#p3006-天平平衡问题" class="headerlink" title="p3006-天平平衡问题"></a>p3006-天平平衡问题</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​你有n个重量不同的砝码和一个天平, 每个砝码可以放在天平的左盘或者右盘或者不放.</p><p>​砝码重量为w1,w2,…,wn</p><p>​问有多少种放置砝码的方式，使得天平平衡?</p><p>​两边均为空，均不放砝码，也算一种方案。</p><p><strong>Input</strong></p><p>​第1行, 1个正整数 n</p><p>​第2行, n 个正整数w1,w2,…,wn, 以空格分隔</p><p><strong>Output</strong></p><p>​天平平衡的放置方案数</p><p><strong>解题思路：</strong></p><p>​同样也是简单递归，遍历所有可能出现的情况。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">average</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> index, <span class="type">int</span> leftSum, <span class="type">int</span> rightSum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(leftSum == rightSum)&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">average</span>(nums, index+<span class="number">1</span>, leftSum + nums[index],rightSum);</span><br><span class="line">    <span class="built_in">average</span>(nums, index+<span class="number">1</span>, leftSum,rightSum + nums[index]);</span><br><span class="line">    <span class="built_in">average</span>(nums, index+<span class="number">1</span>, leftSum, rightSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-数学问题"><a href="#7-数学问题" class="headerlink" title="7.数学问题"></a>7.数学问题</h1><h4 id="p1004-质数判断"><a href="#p1004-质数判断" class="headerlink" title="p1004-质数判断"></a>p1004-质数判断</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​编写一个程序，从用户那里接收一个正整数<code>n</code>，并判断该数字是否为质数。</p><p><strong>Input</strong></p><p>​输入只有一行，包含一个正整数n (1 &lt; n &lt; 10^7) 。</p><p><strong>Output</strong></p><ul><li>如果n是质数，则输出 “Yes”</li><li>如果n不是质数，则输出 “No”</li></ul><p><strong>解题思路：</strong></p><p>​记住6这一数字，我们可以把所有的数表示为6i，6i+1，6i+2，6i+3，6i+4，6i+5，而在这些数中只有6i+1和6i+5可能是质数，其他均不可能是质数。所以我们可以以6为基准进行计算。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num == <span class="number">1</span> || num == <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">2</span> || num == <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num % <span class="number">6</span> != <span class="number">1</span> &amp;&amp; num % <span class="number">6</span> != <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只需要判断到平方根，因为一个数要有约数的话，一定有一个比平方根大和一个比平方根小的约数。</span></span><br><span class="line">    <span class="comment">// 由于下方有判断i-1的条件，如果是i &lt;= sqrt(num)的话，那么可能i-1就取不到，所以要取大一个的数。</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">6</span>; i &lt;= <span class="built_in">sqrt</span>(num)+<span class="number">1</span>; i+=<span class="number">6</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(num % (i<span class="number">-1</span>) == <span class="number">0</span> || num % (i+<span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p3005-求第k小的数"><a href="#p3005-求第k小的数" class="headerlink" title="p3005-求第k小的数"></a>p3005-求第k小的数</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​给定一个包含 ( n ) 个正整数的数组，找出其中不重复的第 ( k ) 个最小整数。</p><p><strong>Input</strong></p><ul><li>第一行输入两个正整数 ( n ) 和 ( k )，分别表示数组的大小和要查询的第k小的数。其中 ( 1 &lt;&#x3D; n &lt;&#x3D; 10^4 )，( 1 &lt;&#x3D; k &lt;&#x3D; 10^3 )。</li><li>第二行输入 ( n ) 个正整数，表示数组中的元素。每个整数的值均小于 ( 3 * 10^4 )，整数之间用空格分隔。</li></ul><p><strong>Output</strong></p><p>​输出第 ( k ) 个最小的不重复整数。</p><p>​如果不存在第 ( k ) 个这样的整数，则输出<code>NO RESULT</code>。</p><p><strong>解题思路：</strong></p><p>​<strong>经典</strong>的（快速）排序+set集合思想算出。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k,<span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = nums[left];</span><br><span class="line">    <span class="type">int</span> i = left, j = right;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] &gt;= x) j--;</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= left &amp;&amp; i &lt; j) nums[i++] = nums[j];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[i] &lt; x)  i++;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;= right &amp;&amp; i &lt; j)  nums[j--] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[i] = x;</span><br><span class="line">    <span class="built_in">quickSort</span>(nums, k, left, i<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(nums, k, i+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-模拟"><a href="#8-模拟" class="headerlink" title="8.模拟"></a>8.模拟</h1><h4 id="p2003-回字形矩阵"><a href="#p2003-回字形矩阵" class="headerlink" title="p2003-回字形矩阵"></a>p2003-回字形矩阵</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>给定一个正整数 (n)，请你生成一个 (n * n) 的回字形矩阵。</p><p>回字形矩阵的特点是：</p><ol><li>矩阵的最外一圈的数字都是1。</li><li>次外一圈的数字都是2。</li><li>以此类推，直到矩阵中心。</li></ol><p>如果 (n) 为偶数，那么最内圈的数字是 (n&#x2F;2)。如果 (n) 为奇数，那么最内圈的数字是 (n&#x2F;2 + 1)。</p><p><strong>Input</strong></p><p>一个正整数 (n) (1 &lt;&#x3D; n &lt;&#x3D; 100)，表示矩阵的大小</p><p><strong>Output</strong></p><p>输出一个 (n * n) 的回字形矩阵。每行包含 (n) 个用空格隔开的整数</p><p><strong>解题思路：</strong></p><p>​此题采用碰壁转向，即到了该转弯的位置就进行转弯，相似的题还有力扣上的<strong>螺旋矩阵，回旋矩阵</strong>等。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, row, column, dx = <span class="number">0</span>, dy = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 这里是判断在哪个位置结束循环。</span></span><br><span class="line">   <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">       row = n/<span class="number">2</span>;</span><br><span class="line">       column = row<span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">       row = n/<span class="number">2</span>;</span><br><span class="line">       column = row;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 这里是碰壁转向的通用模板</span></span><br><span class="line">   <span class="keyword">while</span>(x != row || y != column)&#123;</span><br><span class="line">       num[x][y] = count;</span><br><span class="line">       <span class="keyword">if</span> (dy == <span class="number">1</span> &amp;&amp; (y &gt;= n - <span class="number">1</span> || num[x][y+<span class="number">1</span>] != <span class="number">0</span>))</span><br><span class="line">       &#123;</span><br><span class="line">           dx = <span class="number">1</span>;</span><br><span class="line">           dy = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (dx == <span class="number">1</span> &amp;&amp; (x &gt;= n - <span class="number">1</span> || num[x+<span class="number">1</span>][y] != <span class="number">0</span>))</span><br><span class="line">       &#123;</span><br><span class="line">           dx = <span class="number">0</span>;</span><br><span class="line">           dy = <span class="number">-1</span>;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (dy == <span class="number">-1</span> &amp;&amp; (y &lt;= <span class="number">0</span> || num[x][y<span class="number">-1</span>] != <span class="number">0</span>))</span><br><span class="line">       &#123;</span><br><span class="line">           dx = <span class="number">-1</span>;</span><br><span class="line">           dy = <span class="number">0</span>;</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (dx == <span class="number">-1</span> &amp;&amp; (x &lt;= <span class="number">0</span> || num[x<span class="number">-1</span>][y] != <span class="number">0</span>))</span><br><span class="line">       &#123;</span><br><span class="line">           dx = <span class="number">0</span>;</span><br><span class="line">           dy = <span class="number">1</span>;</span><br><span class="line">           count += <span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       x += dx;</span><br><span class="line">       y += dy;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   num[row][column] = count;</span><br></pre></td></tr></table></figure><h4 id="p2014-约瑟夫环"><a href="#p2014-约瑟夫环" class="headerlink" title="p2014-约瑟夫环"></a>p2014-约瑟夫环</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​n 个人围成一圈，从第一个人开始报数,数到 m 的人出列，再由下一个人重新从 1 开始报数，数到 m 的人再出圈，依次类推，直到所有的人都出圈，请输出依次出圈人的编号。</p><p><strong>Input</strong></p><p>输入两个整数 n,m。 (1&lt;&#x3D; m,n &lt;&#x3D;100)</p><p><strong>Output</strong></p><p>输出一行 n 个整数，按顺序输出每个出圈人的编号。</p><p><strong>解题思路：</strong></p><p>​建立一个vector数组，到指定位置就erase掉需要删除的数据，每次加上m就取余。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        nums[i] = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">        temp = (temp + m - <span class="number">1</span>) % nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> x = nums[temp];</span><br><span class="line">        nums.<span class="built_in">erase</span>(nums.<span class="built_in">begin</span>()+temp);</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-栈"><a href="#9-栈" class="headerlink" title="9.栈"></a>9.栈</h1><h4 id="p2015-表达式括号匹配"><a href="#p2015-表达式括号匹配" class="headerlink" title="p2015-表达式括号匹配"></a>p2015-表达式括号匹配</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​编写一个程序，用于检测一个包含小写英文字母、运算符（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>）和括号的数学表达式的括号是否正确匹配。表达式以<code>@</code>符号结束。你的任务是判断在表达式中的括号是否正确匹配。</p><ul><li>如果括号正确匹配（每个左括号都有一个相应的右括号，并且它们的顺序是正确的），输出<code>YES</code>。</li><li>如果括号不匹配，则输出<code>NO</code>。</li></ul><p><strong>Input</strong></p><ul><li>输入包含一行，即要检查的表达式。表达式的长度小于 255 个字符，并且包含少于 20 对括号。</li></ul><p><strong>Output</strong></p><ul><li>输出包含一行，是<code>YES</code>或<code>NO</code>，表示括号是否正确匹配</li></ul><p><strong>解题思路：</strong></p><p>​使用栈来简化括号匹配的检测。栈先入后出特点恰好与本题括号排序特点一致，即若遇到左括号入栈，遇到右括号时将对应栈顶左括号出栈，则遍历完所有括号后 stack 仍然为空；</p><p>​建立哈希表 dic 构建左右括号对应关系：key左括号，value右括号；这样查询 2个括号是否对应只需 O(1)时间复杂度；建立栈 stack，遍历字符串 s 并按照算法流程一一判断。</p><p><a href="https://leetcode.cn/problems/valid-parentheses/description/">20. 有效的括号 - 力扣（LeetCode）</a></p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;YES&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;NO&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10-双指针"><a href="#10-双指针" class="headerlink" title="10.双指针"></a>10.双指针</h1><h4 id="p3023-移动数组中的零"><a href="#p3023-移动数组中的零" class="headerlink" title="p3023-移动数组中的零"></a>p3023-移动数组中的零</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​给定一个数组<code>nums</code>，将所有<code>0</code>移动到数组的末尾，同时保持非零元素的相对顺序。</p><p>​必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>Input</strong></p><ul><li>第一行：一个整数<code>n</code>，表示数组的元素个数。</li><li>第二行：<code>n</code>个整数。</li></ul><p><strong>Output</strong></p><ul><li>移动后的数组，元素间用空格隔开。</li></ul><p><strong>解题思路：</strong></p><p>​双指针（将i置于要赋值的位置，将j处的值赋给i）+减少cin的时间.</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; res[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// while(res[i] != 0 &amp;&amp; i &lt; res.size())&#123;</span></span><br><span class="line">    <span class="comment">//     i++;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// j = i+1;</span></span><br><span class="line">    <span class="comment">// while(res[j] == 0 &amp;&amp; j &lt; res.size())&#123;</span></span><br><span class="line">    <span class="comment">//     j++;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; res.<span class="built_in">size</span>() &amp;&amp; j &lt; res.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(res[j] != <span class="number">0</span>)&#123;</span><br><span class="line">            res[i] = res[j];</span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">// j++;</span></span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; res.<span class="built_in">size</span>())&#123;</span><br><span class="line">        res[i] = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x: res)&#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="p3024-最长连续不重复子序列"><a href="#p3024-最长连续不重复子序列" class="headerlink" title="p3024-最长连续不重复子序列"></a>p3024-最长连续不重复子序列</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​给定一个长度为<code>n</code>的正整数序列，请找出最长的不包含重复数的连续子序列，并输出其长度。</p><p><strong>Input</strong></p><ul><li>第一行包含一个整数<code>n</code>。</li><li>第二行包含<code>n</code>个整数，表示整数序列。</li></ul><p><strong>Output</strong></p><ul><li>共一行，包含一个整数，表示最长的不包含重复数的连续子序列的长度。</li></ul><p><strong>解题思路：</strong></p><p>​双指针+map，一个指针记录长度左边的位置，一个记录右边的位置，利用map记录每个数字出现的次数，大于1就将i往右移。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; res[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set&lt;int&gt; mySet(res.begin(), res.end());</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; mySet.size();</span></span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; n)&#123;</span><br><span class="line">        mp[res[j]]++;</span><br><span class="line">        <span class="keyword">while</span>(mp[res[j]] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            mp[res[i]]--;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="built_in">max</span>(sum, j-i+<span class="number">1</span>);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-前缀和"><a href="#11-前缀和" class="headerlink" title="11.前缀和"></a>11.前缀和</h1><h4 id="p3025-和为k的子数组"><a href="#p3025-和为k的子数组" class="headerlink" title="p3025-和为k的子数组"></a>p3025-和为k的子数组</h4><p><strong>题目：</strong></p><p><strong>Description</strong></p><p>​给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</p><p><strong>Input</strong></p><ul><li>第一行：一个整数 (n)，表示数组的元素个数。</li><li>第二行：(n) 个整数，表示数组的元素。</li><li>第三行：一个整数 (k)。</li></ul><p><strong>Output</strong></p><ul><li>输出一个整数，表示和为<code>k</code>的连续子数组的个数。</li></ul><p><strong>解题思路：</strong></p><p>​map+前缀和，每次求一个前缀和时，都去遍历map里面的前缀和看是否有符合要求的。此题有一个细节就是mp[0]&#x3D;1，因为当sum&#x3D;k时，这个前缀和没有被记录，所以需要单独列一个出来加上。</p><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 前缀和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 由于下方可能k会等于0，或者第一次出现sum=k的情况，但是这个是没有被记录的，所以首先需要令mp[0]=1</span></span><br><span class="line">    mp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">find</span>(sum-k) != mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">            count += mp[sum-k];</span><br><span class="line">        &#125;</span><br><span class="line">        mp[sum]++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; count;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一些小知识点"><a href="#一些小知识点" class="headerlink" title="一些小知识点"></a>一些小知识点</h1><p>1.set里面是去重并自动进行了排序的</p><p>2.减少cin的时间的两行代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ios_base::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>3.在出现wrong answer的时候可以考虑将int类型改成long long类型，可能是溢出了。</p><p>4.出现runtime error可以考虑数组溢出等问题。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello world！</title>
      <link href="/2024/01/30/hello-world/"/>
      <url>/2024/01/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 入门 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
